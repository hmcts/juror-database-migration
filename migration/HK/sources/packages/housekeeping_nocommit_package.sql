-- Generated by Ora2Pg, the Oracle database Schema converter, version 24.0
-- Copyright 2000-2023 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=172.17.0.2;sid=xe;port=1521

SET client_encoding TO 'UTF8';

SET search_path = hk,public;
\set ON_ERROR_STOP ON

CREATE OR REPLACE PACKAGE Housekeeping_NoCommit IS

/*********************************************************
*  Author  : David Field
*  Created : 5/9/2013 10:45:20 AM
*  Purpose : Housekeeping
*  
*   Change History
*
*   Date    Author     Description
*   ----    ------     -----------
* 8/8/13    Chris W    Renamed the nocommit version to enable
*                      both commit and no commit version to
*                      exist in the database together
*
********************************************************/
  
  -- Public function and procedure declarations
  FUNCTION initiate_run (p_owner_restrict       VARCHAR2 
                        ,p_read_only_mode       BOOLEAN 
                        ,p_max_time             INTEGER) 
                        RETURN number;
  

END Housekeeping_nocommit;



CREATE OR REPLACE PACKAGE BODY Housekeeping_NoCommit IS

/*********************************************************
*  Author  : David Field
*  Created : 5/9/2013 10:45:20 AM
*  Purpose : Housekeeping
*  
*   Change History
*
*   Date    Author     Description
*   ----    ------     -----------
*
********************************************************/
 
  
  FUNCTION initiate_run (p_owner_restrict       VARCHAR2 
                        ,p_read_only_mode       BOOLEAN 
                        ,p_max_time             INTEGER)
                         RETURN number IS
  
    -- main cursor used to select parent records for deletion
    CURSOR c_part_hist(b_court_thresh  INTEGER
                      ,b_bureau_thresh INTEGER
                      ) IS
      SELECT part_no
      ,      owner
      ,      MAX(date_part) maxdate
      FROM   part_hist ph
      WHERE EXISTS (SELECT '1'
                    FROM   hk_owner_restrict  res
                    WHERE  (ph.owner = res.id
                    AND    res.value = 'YES')
                    OR     p_owner_restrict = 'NO'
                    )
      GROUP BY part_no
      ,        owner
      HAVING MAX(date_part) + DECODE(owner,400,b_bureau_thresh,b_court_thresh) < sysdate;

      
    -- A duplicate of the above cursor, but in a count(*) format to check number of 
    -- candidate records  
    CURSOR c_part_hist_count(b_court_thresh  INTEGER
                            ,b_bureau_thresh INTEGER
                            ) IS
      SELECT COUNT(*)
      FROM  (SELECT 1
             FROM   part_hist ph
             WHERE EXISTS (SELECT '1'
                           FROM   hk_owner_restrict  res
                           WHERE  (ph.owner = res.id
                           AND    res.value = 'YES')
                           OR     p_owner_restrict = 'NO'
                          )
             GROUP BY part_no
             ,        owner
             HAVING MAX(date_part) + DECODE(owner,400,b_bureau_thresh,b_court_thresh) < sysdate
             );

      
      -- used for logging functionality
      e_log_error    EXCEPTION; 
      l_file         utl_file.file_type; 
      l_cursor_loops INTEGER := 0;
      l_seq          INTEGER;
      
      -- used for the child rowcounts

      TYPE logs IS TABLE OF integer INDEX BY VARCHAR2(4);

      l_defer_dbf        logs; 
      l_part_hist        logs;
      l_part_expenses    logs;
      l_audit_report     logs;   
      l_cert_lett        logs;   
      l_disq_lett        logs;   
      l_manuals          logs;   
      l_audit_f_report   logs;   
      l_appearances      logs;   
      l_confirm_lett     logs;   
      l_part_amendments  logs;   
      l_def_lett         logs;    
      l_def_denied       logs;   
      l_exc_denied_lett  logs;    
      l_postpone_lett    logs;    
      l_fta_lett         logs;   
      l_request_lett     logs;   
      l_phone_log        logs;    
      l_exc_lett         logs;    
      l_undeliver        logs;    
      l_pool             logs;   

      -- used for the parent row counts
      l_pre_panel             INTEGER;
      l_post_panel            INTEGER;
     
      -- used for error handling
      l_error_stage    VARCHAR2(30);
      e_delete_error   EXCEPTION;
      l_err_msg        VARCHAR2(200);
      e_param_error    EXCEPTION;
      e_max_deletions  EXCEPTION;
      l_pool_errors    INTEGER := 0;
       
      -- time out vars
      l_start_time     DATE    := SYSDATE;  -- time proc started 
      l_time_expired   BOOLEAN := false;    -- has the time expired ?
      e_timeout        EXCEPTION;
      
      -- table parameters
      l_param_court_threshold  INTEGER;
      l_param_bureau_threshold INTEGER;
      l_param_max_deletes      INTEGER;
      
      -- misc
      l_part_count INTEGER;
 
   -----------
   --
   -----------

    PROCEDURE write_params_to_log IS
 
      -- Opens up log file and writes header into
  
      l_filename VARCHAR2(50);
      
      CURSOR c_hk_owner_restrict IS
        SELECT id
        ,      description
        FROM   hk_owner_restrict
        WHERE  upper(value) = 'YES';
        
  
    BEGIN
 
      utl_file.put_line(l_file,'Parameter P_OWNER_RESTRICT      ,'||p_owner_restrict,TRUE);
      utl_file.put_line(l_file,'Parameter P_COURT_AGE_THRESHOLD ,'||l_param_court_threshold,TRUE);
      utl_file.put_line(l_file,'Parameter P_BUREAU_AGE_THRESHOLD,'||l_param_bureau_threshold,TRUE);
      IF p_read_only_mode THEN
        utl_file.put_line(l_file,'Parameter P_READ_ONLY_MODE      ,TRUE',TRUE);
      ELSIF NOT p_read_only_mode THEN
        utl_file.put_line(l_file,'Parameter P_READ_ONLY_MODE      ,FALSE',TRUE);
      ELSE
        utl_file.put_line(l_file,'Parameter P_READ_ONLY_MODE      ,',TRUE);
      END IF;
      utl_file.put_line(l_file,'Parameter P_MAX_TIME            ,'||p_max_time,TRUE);
      utl_file.put_line(l_file,'Parameter P_MAX_DELETES         ,'||l_param_max_deletes,TRUE);

      IF p_owner_restrict = 'YES' THEN

        utl_file.put_line(l_file,'Courts included ',TRUE); 
        FOR l IN c_hk_owner_restrict LOOP
          utl_file.put_line(l_file,l.id||','||l.description,TRUE);
        END LOOP;
      
      END IF;
 
        
    EXCEPTION 
      WHEN OTHERS THEN
    
        RAISE e_log_error;
       
    END write_params_to_log;

   -----------
   --
   -----------

      
   PROCEDURE fetch_parameters IS
   
     -- Get parameters from main param table. There must be three values - if any are not present then
     -- raise e_param_error execpetion which is handled in main block
   
     CURSOR c_hk_params IS
       SELECT key
       ,      value
       FROM   hk_params;
   
   BEGIN
   
  
     FOR l_hk_params IN c_hk_params LOOP
     
       IF l_hk_params.key = 1 THEN
         l_param_court_threshold := l_hk_params.value;
       ELSIF l_hk_params.key = 2 THEN
         l_param_bureau_threshold := l_hk_params.value;
       ELSIF l_hk_params.key = 3 THEN
         l_param_max_deletes := l_hk_params.value;
       END IF;
     END LOOP;
     
     write_params_to_log;

     -- raise error if database stored parameters are not all present
     IF l_param_court_threshold IS NULL OR l_param_bureau_threshold IS NULL OR l_param_max_deletes IS NULL THEN
       RAISE e_param_error;
     END IF;

     -- raise error if command line parameters are not all present
     IF p_owner_restrict IS NULL OR        
        p_read_only_mode IS NULL OR       
        p_max_time       IS NULL OR
        p_owner_restrict NOT IN ('YES','NO') OR
        NOT p_max_time > 0 THEN
        
        RAISE e_param_error;
        
     END IF;      
 
     
   EXCEPTION
     WHEN others THEN
       RAISE e_param_error;
 
   END fetch_parameters;
 
   -----------
   --
   -----------

    PROCEDURE initate_log IS
 
      -- Opens up log file and writes header into
  
      l_filename VARCHAR2(50);
      
    BEGIN
 
      l_filename := 'HK_run_'||TO_CHAR(sysdate,'dd-mon-yyyy_hh24:mi');
  
      l_file := utl_file.fopen('HK_LOG_DIR',l_filename,'w');
   
      utl_file.put_line(l_file,'HK Run started on '||TO_CHAR(sysdate,'dd-mon-yyyy hh24:mi:ss'),TRUE);

     
    EXCEPTION 
      WHEN OTHERS THEN
    
        RAISE e_log_error;
       
    END initate_log;

   -----------
   --
   -----------


   
   PROCEDURE close_log IS
   
   BEGIN

     utl_file.fclose(l_file); 
    
   EXCEPTION 
     WHEN OTHERS THEN
      
       -- error return code
         RAISE e_log_error;
 
   END close_log;
    
   -----------
   --
   -----------
 
   PROCEDURE record_internal_log_start IS
   
  
   BEGIN
   
     SELECT NVL(MAX(seq_id),1) + 1
     INTO   l_seq
     FROM   hk_run_log;
     
   
     INSERT INTO hk_run_log
     (seq_id
     ,start_time
     )
     VALUES
     (l_seq
     ,SYSDATE
     );
     
     COMMIT;
     
   END record_internal_log_start;
   
   
   -----------
   --
   -----------

  
  
    PROCEDURE write_child_rowcounts IS
 
      -- writes results log and closes file
  
      BEGIN
  
      utl_file.put_line(l_file,' ',TRUE); 
      utl_file.put_line(l_file,'Row Counts for POOL child tables',TRUE); 
      utl_file.put_line(l_file,'Table,Before,After,Deleted',TRUE); 
      utl_file.put_line(l_file,'AUDIT_F_REPORT,'||l_audit_f_report('PRE')||','||l_audit_f_report('POST')||','||(l_audit_f_report('PRE')-l_audit_f_report('POST')),TRUE);
      utl_file.put_line(l_file,'APPEARANCES,'||l_appearances('PRE')||','||l_appearances('POST')||','||(l_appearances('PRE')-l_appearances('POST')),TRUE);
      utl_file.put_line(l_file,'AUDIT_REPORT,'||l_audit_report('PRE')||','||l_audit_report('POST')||','||(l_audit_report('PRE')-l_audit_report('POST')),TRUE);
      utl_file.put_line(l_file,'CERT_LETT,'||l_cert_lett('PRE')||','||l_cert_lett('POST')||','||(l_cert_lett('PRE')-l_cert_lett('POST')),TRUE);
      utl_file.put_line(l_file,'CONFIRM_LETT,'||l_confirm_lett('PRE')||','||l_confirm_lett('POST')||','||(l_confirm_lett('PRE')-l_confirm_lett('POST')),TRUE);
      utl_file.put_line(l_file,'DISQ_LETT,'||l_disq_lett('PRE')||','||l_disq_lett('POST')||','||(l_disq_lett('PRE')-l_disq_lett('POST')),TRUE);
      utl_file.put_line(l_file,'DEFER_DBF,'||l_defer_dbf('PRE')||','||l_defer_dbf('POST')||','||(l_defer_dbf('PRE')-l_defer_dbf('POST')),TRUE);
      utl_file.put_line(l_file,'DEF_LETT,'||l_def_lett('PRE')||','||l_def_lett('POST')||','||(l_def_lett('PRE')-l_def_lett('POST')),TRUE);
      utl_file.put_line(l_file,'DEF_DENIED,'||l_def_denied('PRE')||','||l_def_denied('POST')||','||(l_def_denied('PRE')-l_def_denied('POST')),TRUE);
      utl_file.put_line(l_file,'EXC_LETT,'||l_exc_lett('PRE')||','||l_exc_lett('POST')||','||(l_exc_lett('PRE')-l_exc_lett('POST')),TRUE);
      utl_file.put_line(l_file,'EXC_DENIED_LETT,'||l_exc_denied_lett('PRE')||','||l_exc_denied_lett('POST')||','||(l_exc_denied_lett('PRE')-l_exc_denied_lett('POST')),TRUE);
      utl_file.put_line(l_file,'FTA_LETT,'||l_fta_lett('PRE')||','||l_fta_lett('POST')||','||(l_fta_lett('PRE')-l_fta_lett('POST')),TRUE);
      utl_file.put_line(l_file,'MANUALS,'||l_manuals('PRE')||','||l_manuals('POST')||','||(l_manuals('PRE')-l_manuals('POST')),TRUE);
      utl_file.put_line(l_file,'PART_AMENDMENTS,'||l_part_amendments('PRE')||','||l_part_amendments('POST')||','||(l_part_amendments('PRE')-l_part_amendments('POST')),TRUE);
      utl_file.put_line(l_file,'PART_HIST,'||l_part_hist('PRE')||','||l_part_hist('POST')||','||(l_part_hist('PRE')-l_part_hist('POST')),TRUE);
      utl_file.put_line(l_file,'PART_EXPESES,'||l_part_expenses('PRE')||','||l_part_expenses('POST')||','||(l_part_expenses('PRE')-l_part_expenses('POST')),TRUE);
      utl_file.put_line(l_file,'POSTPONE_LETT,'||l_postpone_lett('PRE')||','||l_postpone_lett('POST')||','||(l_postpone_lett('PRE')-l_postpone_lett('POST')),TRUE);
      utl_file.put_line(l_file,'PHONE_LOG,'||l_phone_log('PRE')||','||l_phone_log('POST')||','||(l_phone_log('PRE')-l_phone_log('POST')),TRUE);
      utl_file.put_line(l_file,'REQUEST_LETT,'||l_request_lett('PRE')||','||l_request_lett('POST')||','||(l_request_lett('PRE')-l_request_lett('POST')),TRUE);
      utl_file.put_line(l_file,'UNDELIVER,'||l_undeliver('PRE')||','||l_undeliver('POST')||','||(l_undeliver('PRE')-l_undeliver('POST')),TRUE);
      utl_file.put_line(l_file,' ',TRUE); 
      utl_file.put_line(l_file,'Row Counts for POOL table',TRUE); 
      utl_file.put_line(l_file,'Table,Before,After,Deleted',TRUE); 
      utl_file.put_line(l_file,'POOL,'||l_pool('PRE')||','||l_pool('POST')||','||(l_pool('PRE')-l_pool('POST')),TRUE);


       
    EXCEPTION 
      WHEN OTHERS THEN
      
        RAISE e_log_error;
      
    END write_child_rowcounts;

   -----------
   --
   -----------

   PROCEDURE write_footer (p_code INTEGER) IS
   
   BEGIN

     utl_file.put_line(l_file,' ',TRUE); 
     utl_file.put_line(l_file,'No. of Juror selected for deletion ,'||l_part_count,TRUE);
     utl_file.put_line(l_file,'No. of Juror successfully deleted  ,'||l_cursor_loops,TRUE);
     utl_file.put_line(l_file,'No. of failures                    ,'||l_pool_errors,TRUE);

     IF p_code = 0 THEN
       utl_file.put_line(l_file,'Return Code 0 : Success',TRUE);
     ELSIF p_code = 1 THEN
       utl_file.put_line(l_file,'Return Code 1 : POOL errors raised',TRUE);
     ELSIF p_code = 2 THEN
       utl_file.put_line(l_file,'Return Code 2 : Fatal Error',TRUE);
     ELSIF p_code = 3 THEN
       utl_file.put_line(l_file,'Return Code 3 : Log File Error',TRUE);
     ELSIF p_code = 4 THEN
       utl_file.put_line(l_file,'Return Code 4 : Parameter Error',TRUE);
     ELSIF p_code = 5 THEN
       utl_file.put_line(l_file,'Return Code 5 : Max Deletions Limit',TRUE);
     ELSIF p_code = 6 THEN
       utl_file.put_line(l_file,'Return Code 6 : Timeout',TRUE);
     ELSE  
       utl_file.put_line(l_file,'Unknow Return Code',TRUE);
     END IF;  
     
     -- COMMENT OUT THIS AFTER UNIT TESTING
     ROLLBACK;
     
     UPDATE hk_run_log
     SET    end_time       = SYSDATE
     ,      return_code    = p_code
     ,      jurors_deleted = l_cursor_loops
     ,      jurors_error   = l_pool_errors
     WHERE  seq_id = l_seq;
     
     COMMIT;
      
   END write_footer;

   -----------
   --
   -----------   

    PROCEDURE row_counts (p_stage VARCHAR2) IS
    
    BEGIN
    
        SELECT COUNT(*) INTO l_part_hist(p_stage)       FROM part_hist;
        SELECT COUNT(*) INTO l_part_expenses(p_stage)   FROM part_expenses;
        SELECT COUNT(*) INTO l_audit_report(p_stage)    FROM audit_report;
        SELECT COUNT(*) INTO l_cert_lett(p_stage)       FROM cert_lett;
        SELECT COUNT(*) INTO l_disq_lett(p_stage)       FROM disq_lett;
        SELECT COUNT(*) INTO l_manuals(p_stage)         FROM manuals;
        SELECT COUNT(*) INTO l_audit_f_report(p_stage)  FROM audit_f_report;
        SELECT COUNT(*) INTO l_appearances(p_stage)     FROM appearances;
        SELECT COUNT(*) INTO l_confirm_lett(p_stage)    FROM confirm_lett;
        SELECT COUNT(*) INTO l_part_amendments(p_stage) FROM part_amendments;
        SELECT COUNT(*) INTO l_def_lett(p_stage)        FROM def_lett;
        SELECT COUNT(*) INTO l_def_denied(p_stage)      FROM def_denied;
        SELECT COUNT(*) INTO l_exc_denied_lett(p_stage) FROM exc_denied_lett;
        SELECT COUNT(*) INTO l_postpone_lett(p_stage)   FROM postpone_lett;
        SELECT COUNT(*) INTO l_fta_lett(p_stage)        FROM fta_lett;
        SELECT COUNT(*) INTO l_request_lett(p_stage)    FROM request_lett;
        SELECT COUNT(*) INTO l_phone_log(p_stage)       FROM phone_log;
        SELECT COUNT(*) INTO l_exc_lett(p_stage)        FROM exc_lett;
        SELECT COUNT(*) INTO l_undeliver(p_stage)       FROM undelivr;
        SELECT COUNT(*) INTO l_pool(p_stage)            FROM pool;
        SELECT COUNT(*) INTO l_defer_dbf(p_stage)       FROM defer_dbf;
      
    END row_counts;
  
   -----------
   --
   -----------
  
   PROCEDURE check_time_expired IS
   
     -- parameter p_max_time is the value in minutes for the maximum
     -- time the HK process should run for
   
   BEGIN
   
      IF l_start_time + (( 1/24/60 ) * p_max_time) > sysdate THEN
        l_time_expired := false;
      ELSE
        l_time_expired := true;  
        utl_file.put_line(l_file,'*** TIME EXPIRED AT '||TO_CHAR(sysdate,'dd-mon-yyyy hh24:mi'),TRUE);
        RAISE e_timeout;
      END IF;
   
   END check_time_expired;

   -----------
   --
   -----------
   
   PROCEDURE delete_audit_report(p_part_no VARCHAR, p_owner VARCHAR) IS
   
   
   BEGIN
   
     l_error_stage := 'AUDIT_REPORT';
    
     DELETE audit_report
     WHERE  owner = p_owner
     AND    part_no = p_part_no;
 
     utl_file.put(l_file,SQL%ROWCOUNT||',');

     l_error_stage := 'AUDIT_F_REPORT';

     DELETE audit_f_report
     WHERE  owner = p_owner
     AND    part_no = p_part_no;
 
     utl_file.put(l_file,SQL%ROWCOUNT||',');

      
   EXCEPTION 
     WHEN others THEN
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       RAISE e_delete_error; 
 
   END delete_audit_report;
 
   -----------
   --
   -----------
 
   
   PROCEDURE delete_part_hist(p_part_no VARCHAR, p_owner VARCHAR) IS
   
   BEGIN
   
     l_error_stage := 'PART_HIST';
    
     DELETE part_hist
     WHERE  owner = p_owner
     AND    part_no = p_part_no;
     
     utl_file.put(l_file,SQL%ROWCOUNT||',');

      
   EXCEPTION 
     WHEN others THEN
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       RAISE e_delete_error; 
 
   END delete_part_hist;
 
   -----------
   --
   -----------
 
   PROCEDURE delete_part_expenses(p_part_no VARCHAR, p_owner VARCHAR) IS
   
   
   BEGIN
   
     l_error_stage := 'PART_EXPENSES';

    
     DELETE part_expenses
     WHERE  owner = p_owner
     AND    part_no = p_part_no;
  
     utl_file.put(l_file,SQL%ROWCOUNT||',');

     l_error_stage := 'APPEARANCES';
    
     DELETE appearances
     WHERE  owner = p_owner
     AND    part_no = p_part_no;

     utl_file.put(l_file,SQL%ROWCOUNT||',');

      
   EXCEPTION 
     WHEN others THEN
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       RAISE e_delete_error; 
 
   END delete_part_expenses;
 
   -----------
   --
   -----------
 
   PROCEDURE delete_cert_lett(p_part_no VARCHAR, p_owner VARCHAR) IS
   
   
   BEGIN
   
     l_error_stage := 'CERT_LETT';
    
     DELETE cert_lett
     WHERE  owner = p_owner
     AND    part_no = p_part_no;

     utl_file.put(l_file,SQL%ROWCOUNT||',');
      
   EXCEPTION 
     WHEN others THEN
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       RAISE e_delete_error; 
 
   END delete_cert_lett;
 
   -----------
   --
   -----------
  
   PROCEDURE delete_disq_lett(p_part_no VARCHAR, p_owner VARCHAR) IS
   
   
   BEGIN
   
     l_error_stage := 'DISQ_LETT';
    
     DELETE disq_lett
     WHERE  owner = p_owner
     AND    part_no = p_part_no;
      
     utl_file.put(l_file,SQL%ROWCOUNT||',');
 
   EXCEPTION 
     WHEN others THEN
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       RAISE e_delete_error; 
 
   END delete_disq_lett;
 
   -----------
   --
   -----------
  
   PROCEDURE delete_manuals(p_part_no VARCHAR, p_owner VARCHAR) IS
   
   
   BEGIN
   
     l_error_stage := 'MANUALS';
    
     DELETE manuals
     WHERE  owner = p_owner
     AND    part_no = p_part_no;
   
     utl_file.put(l_file,SQL%ROWCOUNT||',');
      
   EXCEPTION 
     WHEN others THEN
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       RAISE e_delete_error; 
 
   END delete_manuals;
 
   -----------
   --
   -----------
   
   PROCEDURE delete_confirm_lett(p_part_no VARCHAR, p_owner VARCHAR) IS
   
   
   BEGIN
   
     l_error_stage := 'CONFIRM_LETT';
    
     DELETE confirm_lett
     WHERE  owner = p_owner
     AND    part_no = p_part_no;
 
     utl_file.put(l_file,SQL%ROWCOUNT||',');
      
   EXCEPTION 
     WHEN others THEN
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       RAISE e_delete_error; 
 
   END delete_confirm_lett;
 
   -----------
   --
   -----------
 
   PROCEDURE delete_part_amendments(p_part_no VARCHAR, p_owner VARCHAR) IS
   
   
   BEGIN
   
     l_error_stage := 'PART_AMENDMENTS';
    
     DELETE part_amendments
     WHERE  owner = p_owner
     AND    part_no = p_part_no;
 
     utl_file.put(l_file,SQL%ROWCOUNT||',');
       
   EXCEPTION 
     WHEN others THEN
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       RAISE e_delete_error; 
 
   END delete_part_amendments;
 
   -----------
   --
   -----------
   PROCEDURE delete_exc_denied_lett(p_part_no VARCHAR, p_owner VARCHAR) IS
   
   BEGIN
   
     l_error_stage := 'exc_denied_lett';
    
     DELETE exc_denied_lett
     WHERE  owner = p_owner
     AND    part_no = p_part_no;

     utl_file.put(l_file,SQL%ROWCOUNT||',');
      
   EXCEPTION 
     WHEN others THEN
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       RAISE e_delete_error; 
 
   END delete_exc_denied_lett;
 
   -----------
   --
   -----------

   PROCEDURE delete_def_lett(p_part_no VARCHAR, p_owner VARCHAR) IS
   
   BEGIN
   
     l_error_stage := 'def_lett';
    
     DELETE def_lett
     WHERE  owner = p_owner
     AND    part_no = p_part_no;

     utl_file.put(l_file,SQL%ROWCOUNT||',');
      
   EXCEPTION 
     WHEN others THEN
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       RAISE e_delete_error; 
 
   END delete_def_lett;
 
   -----------
   --
   -----------
 
   PROCEDURE delete_def_denied(p_part_no VARCHAR, p_owner VARCHAR) IS
   
   BEGIN
   
     l_error_stage := 'def_denied';
    
     DELETE def_denied
     WHERE  owner = p_owner
     AND    part_no = p_part_no;
 
     utl_file.put(l_file,SQL%ROWCOUNT||',');
      
   EXCEPTION 
     WHEN others THEN
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       RAISE e_delete_error; 
 
   END delete_def_denied;
 
   -----------
   --
   -----------

   PROCEDURE delete_defer_dbf(p_part_no VARCHAR, p_owner VARCHAR) IS
   
   BEGIN
   
     l_error_stage := 'defer_dbf';
    
     DELETE defer_dbf
     WHERE  owner = p_owner
     AND    part_no = p_part_no;

     utl_file.put(l_file,SQL%ROWCOUNT||',' );
      
   EXCEPTION 
     WHEN others THEN
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       RAISE e_delete_error; 
 
   END delete_defer_dbf;
 
   -----------
   --
   -----------


   PROCEDURE delete_undeliver(p_part_no VARCHAR, p_owner VARCHAR) IS
   
   BEGIN
   
     l_error_stage := 'undeliver';
    
     DELETE undelivr
     WHERE  owner = p_owner
     AND    part_no = p_part_no;

     utl_file.put(l_file,SQL%ROWCOUNT||',');
       
   EXCEPTION 
     WHEN others THEN
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       RAISE e_delete_error; 
 
   END delete_undeliver;
 
   -----------
   --
   -----------

   PROCEDURE delete_exc_lett(p_part_no VARCHAR, p_owner VARCHAR) IS
   
   
   BEGIN
   
     l_error_stage := 'exc_lett';
  
     DELETE exc_lett
     WHERE  owner = p_owner
     AND    part_no = p_part_no;

     utl_file.put(l_file,SQL%ROWCOUNT||',');
      
   EXCEPTION 
     WHEN others THEN
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       RAISE e_delete_error; 
 
   END delete_exc_lett;
 
   -----------
   --
   -----------

   PROCEDURE delete_phone_log(p_part_no VARCHAR, p_owner VARCHAR) IS
   
   BEGIN
   
     l_error_stage := 'phone_log';
    
     DELETE phone_log
     WHERE  owner = p_owner
     AND    part_no = p_part_no;

     utl_file.put(l_file,SQL%ROWCOUNT||',');
      
   EXCEPTION 
     WHEN others THEN
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       RAISE e_delete_error; 
 
   END delete_phone_log;
 
   -----------
   --
   -----------

   PROCEDURE delete_request_lett(p_part_no VARCHAR, p_owner VARCHAR) IS
   
   BEGIN
   
     l_error_stage := 'request_lett';
    
     DELETE request_lett
     WHERE  owner = p_owner
     AND    part_no = p_part_no;
 
     utl_file.put(l_file,SQL%ROWCOUNT||',' );
      
   EXCEPTION 
     WHEN others THEN
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       RAISE e_delete_error; 
 
   END delete_request_lett;
 
   -----------
   --
   -----------

   PROCEDURE delete_fta_lett(p_part_no VARCHAR, p_owner VARCHAR) IS
   
   BEGIN
   
     l_error_stage := 'fta_lett';
    
     DELETE fta_lett
     WHERE  owner = p_owner
     AND    part_no = p_part_no;
 
     utl_file.put(l_file,SQL%ROWCOUNT||',');
      
   EXCEPTION 
     WHEN others THEN
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       RAISE e_delete_error; 
 
   END delete_fta_lett;
 
   -----------
   --
   -----------

   PROCEDURE delete_postpone_lett(p_part_no VARCHAR, p_owner VARCHAR) IS
   
   BEGIN
   
     l_error_stage := 'postpone_lett';
    
     DELETE postpone_lett
     WHERE  owner = p_owner
     AND    part_no = p_part_no;

     utl_file.put(l_file,SQL%ROWCOUNT||',');
      
   EXCEPTION 
     WHEN others THEN
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       RAISE e_delete_error; 
 
   END delete_postpone_lett;
 
   -----------
   --
   -----------

   PROCEDURE delete_pool(p_part_no VARCHAR, p_owner VARCHAR) IS
   
   BEGIN
   
     l_error_stage := 'pool';
    
     DELETE pool
     WHERE  owner = p_owner
     AND    part_no = p_part_no;

     utl_file.put_line(l_file,SQL%ROWCOUNT ,TRUE);
      
   EXCEPTION 
     WHEN others THEN
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       RAISE e_delete_error; 
 
   END delete_pool;
 
   -----------
   --
   -----------

   PROCEDURE delete_panel (p_part_no VARCHAR, p_owner VARCHAR) IS 
   
   BEGIN
   
     l_error_stage := 'PANEL';
    
     DELETE panel
     WHERE  owner = p_owner
     AND    part_no = p_part_no;
 
     utl_file.put(l_file,SQL%ROWCOUNT||',');
       
   EXCEPTION 
     WHEN others THEN
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       RAISE e_delete_error; 
 
   END delete_panel;
   
   -----------
   --
   -----------

   PROCEDURE delete_sa_abaccus IS 
   
     l_start DATE;
   
   BEGIN
    
     l_start := SYSDATE;
    
     DELETE abaccus
     WHERE  creation_date + l_param_bureau_threshold < SYSDATE; 

     utl_file.put_line(l_file,'ABACCUS,'||SQL%ROWCOUNT||','||TO_CHAR(l_start,'DD-MM-YYYY hh24:MI:SS')||','||TO_CHAR(sysdate,'DD-MM-YYYY hh24:MI:SS'),TRUE);
 
      IF p_read_only_mode THEN
        ROLLBACK;
      ELSE
        NULL;
        -- COMMIT;  **testing
      END IF;
     
     check_time_expired;
       
   EXCEPTION 
     WHEN e_timeout THEN
       raise e_timeout;

     WHEN others THEN
     
       ROLLBACK;
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       utl_file.put_line(l_file,'ERROR Delete from ABACCUS',TRUE);
       utl_file.put_line(l_file,l_err_msg,TRUE);
 
   END delete_sa_abaccus;
   
   -----------
   --
   -----------

   PROCEDURE delete_sa_attendance IS 
  
     l_start DATE;
   
   BEGIN
    
     l_start := SYSDATE;
 
     DELETE attendance
     WHERE  month_start + l_param_court_threshold < SYSDATE; 

     utl_file.put_line(l_file,'ATTENDANCE,'||SQL%ROWCOUNT||','||TO_CHAR(l_start,'DD-MM-YYYY hh24:MI:SS')||','||TO_CHAR(sysdate,'DD-MM-YYYY hh24:MI:SS'),TRUE);
    
      IF p_read_only_mode THEN
        ROLLBACK;
      ELSE
        NULL;
        -- COMMIT;  **testing
      END IF;
  
     
     check_time_expired;
       
   EXCEPTION 
     WHEN e_timeout THEN
       raise e_timeout;

     WHEN others THEN
   
       ROLLBACK;
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       utl_file.put_line(l_file,'ERROR Delete from ATTENDANCE',TRUE);
       utl_file.put_line(l_file,l_err_msg,TRUE);
 
   END delete_sa_attendAnce;
   
   -----------
   --
   -----------

   PROCEDURE delete_sa_content_store IS 

    l_start DATE;
   
   BEGIN
    
     l_start := SYSDATE;

     DELETE content_store
     WHERE  date_on_q_for_send + l_param_court_threshold < SYSDATE; 

     utl_file.put_line(l_file,'CONTENT_STORE,'||SQL%ROWCOUNT||','||TO_CHAR(l_start,'DD-MM-YYYY hh24:MI:SS')||','||TO_CHAR(sysdate,'DD-MM-YYYY hh24:MI:SS'),TRUE);
     
      IF p_read_only_mode THEN
        ROLLBACK;
      ELSE
        NULL;
        -- COMMIT;  **testing
      END IF;

     
     check_time_expired;
       
   EXCEPTION 
     WHEN e_timeout THEN
       raise e_timeout;
   
     WHEN others THEN
     
       ROLLBACK;
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       utl_file.put_line(l_file,'ERROR Delete from CONTENT_STORE',TRUE);
       utl_file.put_line(l_file,l_err_msg,TRUE);
 
   END delete_sa_content_store;
   
   -----------
   --
   -----------

   PROCEDURE delete_sa_error_log IS 

    l_start DATE;
   
   BEGIN
    
     l_start := SYSDATE;
 
     DELETE error_log
     WHERE  time_stamp + l_param_court_threshold < SYSDATE; 
    
     utl_file.put_line(l_file,'ERROR_LOG,'||SQL%ROWCOUNT||','||TO_CHAR(l_start,'DD-MM-YYYY hh24:MI:SS')||','||TO_CHAR(sysdate,'DD-MM-YYYY hh24:MI:SS'),TRUE);

      IF p_read_only_mode THEN
        ROLLBACK;
      ELSE
        NULL;
        -- COMMIT;  **testing
      END IF;
     
     check_time_expired;
       
   EXCEPTION 
     WHEN e_timeout THEN
       raise e_timeout;
   
     WHEN others THEN
  
       ROLLBACK;
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       utl_file.put_line(l_file,'ERROR Delete from ERROR_LOG',TRUE);
       utl_file.put_line(l_file,l_err_msg,TRUE);
 
   END delete_sa_error_log;

   -----------
   --
   -----------

   PROCEDURE delete_sa_holidays IS 

    l_start DATE;
   
   
   BEGIN
    
     l_start := SYSDATE;

     DELETE holidays
     WHERE  holiday + l_param_court_threshold < SYSDATE; 
 
     utl_file.put_line(l_file,'HOLIDAYS,'||SQL%ROWCOUNT||','||TO_CHAR(l_start,'DD-MM-YYYY hh24:MI:SS')||','||TO_CHAR(sysdate,'DD-MM-YYYY hh24:MI:SS'),TRUE);

      IF p_read_only_mode THEN
        ROLLBACK;
      ELSE
        NULL;
        -- COMMIT;  **testing
      END IF;
    
     
     check_time_expired;
       
   EXCEPTION 
     WHEN e_timeout THEN
       raise e_timeout;
   
     WHEN others THEN
 
       ROLLBACK;
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       utl_file.put_line(l_file,'ERROR Delete from HOLIDAYS',TRUE);
       utl_file.put_line(l_file,l_err_msg,TRUE);
 
   END delete_sa_holidays;

   -----------
   --
   -----------

   PROCEDURE delete_sa_print_files IS 

    l_start DATE;
   
   BEGIN

     l_start := SYSDATE;
    
     DELETE print_files
     WHERE  creation_date + l_param_bureau_threshold < SYSDATE; 

     utl_file.put_line(l_file,'PRINT_FILES,'||SQL%ROWCOUNT||','||TO_CHAR(l_start,'DD-MM-YYYY hh24:MI:SS')||','||TO_CHAR(sysdate,'DD-MM-YYYY hh24:MI:SS'),TRUE);
 
      IF p_read_only_mode THEN
        ROLLBACK;
      ELSE
        NULL;
        -- COMMIT;  **testing
      END IF;
    
     check_time_expired;
       
   EXCEPTION 
     WHEN e_timeout THEN
       raise e_timeout;
   
     WHEN others THEN

       ROLLBACK;
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       utl_file.put_line(l_file,'ERROR Delete from PRINT_FILES',TRUE);
       utl_file.put_line(l_file,l_err_msg,TRUE);
 
   END delete_sa_print_files;

   -----------
   --
   -----------

   PROCEDURE delete_sa_pl_xml_status IS 

    l_start DATE;
   
   BEGIN
    
     l_start := SYSDATE;


     DELETE pl_xml_status
     WHERE  date_time_stamp + l_param_court_threshold < SYSDATE; 
    
     utl_file.put_line(l_file,'PL_XML_STATUS,'||SQL%ROWCOUNT||','||TO_CHAR(l_start,'DD-MM-YYYY hh24:MI:SS')||','||TO_CHAR(sysdate,'DD-MM-YYYY hh24:MI:SS'),TRUE);

      IF p_read_only_mode THEN
        ROLLBACK;
      ELSE
        NULL;
        -- COMMIT;  **testing
      END IF;
     
     check_time_expired;
       
   EXCEPTION 
     WHEN e_timeout THEN
       raise e_timeout;
   
     WHEN others THEN

       ROLLBACK;
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       utl_file.put_line(l_file,'ERROR Delete from PL_XML_STATUS',TRUE);
       utl_file.put_line(l_file,l_err_msg,TRUE);
 
   END delete_sa_pl_xml_status;
   
   -----------
   --
   -----------

   PROCEDURE delete_sa_coroner IS 

     l_error_point  VARCHAR2(30);
     l_start DATE;
   
   BEGIN

     l_start := SYSDATE;

     l_error_point := 'CORONER_POOL_DETAIL';
 
        
     DELETE coroner_pool_detail
     WHERE  cor_pool_no IN (SELECT cor_pool_no
                            FROM   coroner_pool
                            WHERE  cor_service_dt + l_param_bureau_threshold < SYSDATE
                            ); 
     utl_file.put_line(l_file,'CORONER_POOL_DETAIL,'||SQL%ROWCOUNT||','||TO_CHAR(l_start,'DD-MM-YYYY hh24:MI:SS')||','||TO_CHAR(sysdate,'DD-MM-YYYY hh24:MI:SS') ,TRUE);
                             
 
     l_error_point := 'CORONER_POOL';
                           
     l_start := SYSDATE;

     DELETE coroner_pool
     WHERE  cor_service_dt + l_param_bureau_threshold < SYSDATE;

     utl_file.put_line(l_file,'CORONER_POOL,'||SQL%ROWCOUNT||','||TO_CHAR(l_start,'DD-MM-YYYY hh24:MI:SS')||','||TO_CHAR(sysdate,'DD-MM-YYYY hh24:MI:SS'),TRUE);
                           
      IF p_read_only_mode THEN
        ROLLBACK;
      ELSE
        NULL;
        -- COMMIT;  **testing
      END IF;

     
     check_time_expired;
       
   EXCEPTION 
     WHEN e_timeout THEN
       raise e_timeout;
   
     WHEN others THEN
     
       ROLLBACK;
  
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       utl_file.put_line(l_file,'ERROR Delete from '||l_error_point,TRUE);
       utl_file.put_line(l_file,l_err_msg,TRUE);
 
   END delete_sa_coroner;
   
     
   -----------
   --
   -----------
 
   PROCEDURE delete_sa_module_machine_xref IS 

    l_start DATE;
   
   BEGIN
    
     l_start := SYSDATE;

     utl_file.put_line(l_file,'MODULE_MACHINE_XREF,'||SQL%ROWCOUNT||','||TO_CHAR(l_start,'DD-MM-YYYY hh24:MI:SS')||','||TO_CHAR(sysdate,'DD-MM-YYYY hh24:MI:SS'),TRUE);

     DELETE module_machine_xref
     WHERE  last_update + l_param_court_threshold < SYSDATE; 
    
      IF p_read_only_mode THEN
        ROLLBACK;
      ELSE
        NULL;
        -- COMMIT;  **testing
      END IF;

     
     check_time_expired;
       
   EXCEPTION 
     WHEN e_timeout THEN
       raise e_timeout;
   
     WHEN others THEN
 
       ROLLBACK;
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       utl_file.put_line(l_file,'ERROR Delete from MODULE_MACHINE_XREF',TRUE);
       utl_file.put_line(l_file,l_err_msg,TRUE);
 
   END delete_sa_module_machine_xref;


   -----------
   --
   -----------
 
   PROCEDURE delete_sa_peak_usage IS 

    l_start DATE;
   
   BEGIN

     l_start := SYSDATE;

    
     DELETE peak_usage
     WHERE  vd_date + l_param_court_threshold < SYSDATE; 
    
     utl_file.put_line(l_file,'PEAK_USAGE,'||SQL%ROWCOUNT||','||TO_CHAR(l_start,'DD-MM-YYYY hh24:MI:SS')||','||TO_CHAR(sysdate,'DD-MM-YYYY hh24:MI:SS'),TRUE);
 
       IF p_read_only_mode THEN
        ROLLBACK;
      ELSE
        NULL;
        -- COMMIT;  **testing
      END IF;

     
     check_time_expired;
       
   EXCEPTION 
     WHEN e_timeout THEN
       raise e_timeout;
   
     WHEN others THEN
     
       ROLLBACK;
 
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       utl_file.put_line(l_file,'ERROR Delete from PEAK_USAGE',TRUE);
       utl_file.put_line(l_file,l_err_msg,TRUE);
 
   END delete_sa_peak_usage;   

   -----------
   --
   -----------

   PROCEDURE delete_sa_aramis_payments IS 

     l_start DATE;
   
   BEGIN

     l_start := SYSDATE;
    
     DELETE aramis_payments
     WHERE  creation_date + l_param_court_threshold < SYSDATE; 

     utl_file.put_line(l_file,'ARAMIS_PAYMENTS,'||SQL%ROWCOUNT||','||TO_CHAR(l_start,'DD-MM-YYYY hh24:MI:SS')||','||TO_CHAR(sysdate,'DD-MM-YYYY hh24:MI:SS'),TRUE);

      IF p_read_only_mode THEN
        ROLLBACK;
      ELSE
        NULL;
        -- COMMIT;  **testing
      END IF;

     
     check_time_expired;
       
   EXCEPTION 
     WHEN e_timeout THEN
       raise e_timeout;
   
     WHEN others THEN
     
       ROLLBACK;
 
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       utl_file.put_line(l_file,'ERROR Delete from ARAMIS_PAYMENTS',TRUE);
       utl_file.put_line(l_file,l_err_msg,TRUE);
 
   END delete_sa_aramis_payments;   


   -----------
   --
   -----------
   
   PROCEDURE parent_delete_trial IS 
   
     l_start DATE;
     
   BEGIN
   
     l_error_stage := 'ACCUSED';
 
     utl_file.put_line(l_file,' ',TRUE); 
     utl_file.put_line(l_file,'Row Counts for POOL PARENT tables',TRUE); 
     utl_file.put_line(l_file,'Table,Deleted,Start Time,End Time',TRUE); 
  
      l_start := SYSDATE;
    
     DELETE accused ac
     WHERE  EXISTS (SELECT null 
                    FROM   trial tr
                    WHERE  trial_end_date + l_param_court_threshold < sysdate
                    AND    tr.owner = ac.owner
                    AND    tr.trial_no = ac.trial_no
                    AND NOT EXISTS (SELECT null
                                    FROM   panel pl
                                    WHERE  tr.trial_no = pl.trial_no 
                                    AND    tr.owner = pl.owner
                                    )
                    );
  
     utl_file.put_line(l_file,'ACCUSED,'||SQL%ROWCOUNT||','||TO_CHAR(l_start,'DD-MM-YYYY hh24:MI:SS')||','||TO_CHAR(sysdate,'DD-MM-YYYY hh24:MI:SS') ,TRUE);
 
       
     l_error_stage := 'TRIAL';
     l_start := SYSDATE;
 
     DELETE trial ab
     WHERE  trial_end_date + l_param_court_threshold < sysdate
     AND NOT EXISTS (SELECT null
                     FROM   panel pl
                     WHERE  ab.trial_no = pl.trial_no 
                     AND    ab.owner = pl.owner
                     );
                        
     utl_file.put_line(l_file,'TRIAL,'||SQL%ROWCOUNT||','||TO_CHAR(l_start,'DD-MM-YYYY hh24:MI:SS')||','||TO_CHAR(sysdate,'DD-MM-YYYY hh24:MI:SS') ,TRUE);
     
      IF p_read_only_mode THEN
        ROLLBACK;
      ELSE
        NULL;
        -- COMMIT;  **testing
      END IF;


   EXCEPTION 
     WHEN others THEN
     
       ROLLBACK;
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       RAISE e_delete_error; 
 
   END parent_delete_trial;
   
   -----------
   --
   -----------
   
   PROCEDURE parent_delete_unique_pool IS
 
     l_pool_comments INTEGER;
     l_pool_stats    INTEGER;
     l_pool_hist     INTEGER;
     l_start         DATE;

   
   BEGIN
 
     l_error_stage := 'POOL_COMMENTS';
     l_start := SYSDATE;
   
     DELETE pool_comments  pc
     WHERE  EXISTS (SELECT null
                    FROM    unique_pool up
                    WHERE   pc.owner = up.owner
                    AND     pc.pool_no = up.pool_no
                    AND     return_date + DECODE(owner,400,l_param_bureau_threshold,l_param_court_threshold) < sysdate
                    AND NOT EXISTS (SELECT null
                                    FROM   pool p
                                    WHERE  p.pool_no = up.pool_no
                                    AND    p.owner = up.owner
                                    )
                    );        
                    
     utl_file.put_line(l_file,'POOL_COMMENTS,'||SQL%ROWCOUNT||','||TO_CHAR(l_start,'DD-MM-YYYY hh24:MI:SS')||','||TO_CHAR(sysdate,'DD-MM-YYYY hh24:MI:SS') ,TRUE);

     l_error_stage := 'POOL_STATS';
     l_start := SYSDATE;

 
     DELETE pool_stats  pc
     WHERE  EXISTS (SELECT null
                    FROM    unique_pool up
                    WHERE   pc.owner = up.owner
                    AND     pc.pool_no = up.pool_no
                    AND     return_date +  DECODE(owner,400,l_param_bureau_threshold,l_param_court_threshold) < sysdate
                    AND NOT EXISTS (SELECT null
                                    FROM   pool p
                                    WHERE  p.pool_no = up.pool_no
                                    AND    p.owner = up.owner
                                    )
                    );

     utl_file.put_line(l_file,'POOL_STATS,'||SQL%ROWCOUNT||','||TO_CHAR(l_start,'DD-MM-YYYY hh24:MI:SS')||','||TO_CHAR(sysdate,'DD-MM-YYYY hh24:MI:SS') ,TRUE);

     l_error_stage := 'POOL_HIST';
     l_start := SYSDATE;


     DELETE pool_hist  pc
     WHERE  EXISTS (SELECT null
                    FROM    unique_pool up
                    WHERE   pc.owner = up.owner
                    AND     pc.pool_no = up.pool_no
                    AND     return_date + DECODE(owner,400,l_param_bureau_threshold,l_param_court_threshold) < sysdate
                    AND NOT EXISTS (SELECT null
                                    FROM   pool p
                                    WHERE  p.pool_no = up.pool_no
                                    AND    p.owner = up.owner
                                    )
                    );

    utl_file.put_line(l_file,'POOL_HIST,'||SQL%ROWCOUNT||','||TO_CHAR(l_start,'DD-MM-YYYY hh24:MI:SS')||','||TO_CHAR(sysdate,'DD-MM-YYYY hh24:MI:SS' ),TRUE);
    l_error_stage := 'UNIQUE_POOL';
    l_start := SYSDATE;
   
     DELETE unique_pool up
     WHERE  return_date + DECODE(owner,400,l_param_bureau_threshold,l_param_court_threshold) < sysdate
     AND    NOT EXISTS (SELECT null
                        FROM   pool p
                        WHERE  p.pool_no = up.pool_no
                        AND    p.owner = up.owner
                        );
   
     utl_file.put_line(l_file,'UNIQUE_POOL,'||SQL%ROWCOUNT||','||TO_CHAR(l_start,'DD-MM-YYYY hh24:MI:SS')||','||TO_CHAR(sysdate,'DD-MM-YYYY hh24:MI:SS' ),TRUE);
  
      IF p_read_only_mode THEN
        ROLLBACK;
      ELSE
        NULL;
        -- COMMIT;  **testing
      END IF;

   
    EXCEPTION 

     WHEN others THEN
     
       ROLLBACK;
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       RAISE e_delete_error; 
 
   END parent_delete_unique_pool;   
   
   -----------
   --
   -----------
  
   
   PROCEDURE report_error(p_part_no VARCHAR, p_owner VARCHAR) IS
  
   BEGIN
    
     utl_file.put_line(l_file,'ERROR. owner:'||p_owner||' part_no:'||p_part_no,TRUE);
     utl_file.put_line(l_file,l_err_msg,TRUE);
     utl_file.put_line(l_file,'Stage : '||l_error_stage);
        
 
   END report_error;

   -----------
   --
   -----------
    
   -- Main body
   BEGIN
  
    record_internal_log_start;
  
    -- open log file   
    initate_log;
  
    -- fetch parameters from HK_PARAMS table
    fetch_parameters;
   
    -- count number of parent records
    OPEN c_part_hist_count(l_param_court_threshold,l_param_bureau_threshold);
    FETCH c_part_hist_count INTO l_part_count;
    CLOSE c_part_hist_count;
   
    IF l_part_count > l_param_max_deletes THEN
       utl_file.put_line(l_file,'Maximum Deletes Parameter exceed. Expected Deletes : '||l_part_count,TRUE);
      RAISE e_max_deletions;
    END IF;   

    -- gather pre-hk row counts
    row_counts('PRE');
 
    IF p_read_only_mode THEN
      utl_file.put_line(l_file,'Time of Deletion,PART_NO,OWNER,Max_DATE_PART',TRUE);
    ELSE
      utl_file.put_line(l_file,'Time of Deletion,PART_NO,OWNER,Max_DATE_PART,AUDIT_REPORT,AUDIT_F_REPORT,PART_EXPENSES,APPEARANCES,CERT_LETT,CONFIRM_LETT,DEFER_DBF,DEF_LETT,DEF_DENIED,DISQ_LETT,EXC_DENIED_LETT,EXC_LETT,FTA_LETT,MANUALS,PANEL,PART_HIST,PART_AMENDMENTS,POSTPONE_LETT,PHONE_LOG,REQUEST_LETT,UNDELIVR,POOL',TRUE);
    END IF;    

  
    FOR l_part_hist IN c_part_hist(l_param_court_threshold,l_param_bureau_threshold) LOOP

      --  dbms_output.put_line('5');
      BEGIN
     
              
     -- write parent record identifier to log
     --   IF p_read_only_mode THEN
     --     utl_file.put_line(l_file,TO_CHAR(sysdate,'dd/mm/yyyy hh24:mi:ss')||':POOL Part_no='||l_part_hist.part_no||' Owner='||l_part_hist.owner||' Date='||TO_CHAR(l_part_hist.maxdate,'dd-mon-yyyy'),TRUE);
     --   ELSE
     --     utl_file.put(l_file,TO_CHAR(sysdate,'dd/mm/yyyy hh24:mi:ss')||':POOL Parent Record - Part_no='||l_part_hist.part_no||' Owner='||l_part_hist.owner||' Date='||TO_CHAR(l_part_hist.maxdate,'dd-mon-yyyy'||','));
     --   END IF;    
 
      --write parent record identifier to log
        IF p_read_only_mode THEN
          utl_file.put_line(l_file,TO_CHAR(sysdate,'dd/mm/yyyy hh24:mi:ss')||','||l_part_hist.part_no||','||l_part_hist.owner||','||TO_CHAR(l_part_hist.maxdate,'dd/mm/yyyy'),TRUE);
        ELSE
          utl_file.put(l_file,TO_CHAR(sysdate,'dd/mm/yyyy hh24:mi:ss')||','||l_part_hist.part_no||','||l_part_hist.owner||','||TO_CHAR(l_part_hist.maxdate,'dd/mm/yyyy'||','));
        END IF;    
  


        IF NOT p_read_only_mode THEN
        
          -- Delete child tables level 3
          delete_audit_report(l_part_hist.part_no,l_part_hist.owner);
          delete_part_expenses(l_part_hist.part_no,l_part_hist.owner);

          -- Delete child tables level 2
          delete_cert_lett(l_part_hist.part_no,l_part_hist.owner);
          delete_confirm_lett(l_part_hist.part_no,l_part_hist.owner);
          delete_defer_dbf(l_part_hist.part_no,l_part_hist.owner);
          delete_def_lett(l_part_hist.part_no,l_part_hist.owner);
          delete_def_denied(                                     l_part_hist.part_no,l_part_hist.owner);
          delete_disq_lett(l_part_hist.part_no,l_part_hist.owner);
          delete_exc_denied_lett(l_part_hist.part_no,l_part_hist.owner);
          delete_exc_lett(l_part_hist.part_no,l_part_hist.owner);
          delete_fta_lett(l_part_hist.part_no,l_part_hist.owner);
          delete_manuals(l_part_hist.part_no,l_part_hist.owner);
          delete_panel(l_part_hist.part_no,l_part_hist.owner);
          delete_part_hist(l_part_hist.part_no,l_part_hist.owner);
          delete_part_amendments(l_part_hist.part_no,l_part_hist.owner);
          delete_postpone_lett(l_part_hist.part_no,l_part_hist.owner);
          delete_phone_log(l_part_hist.part_no,l_part_hist.owner);
          delete_request_lett(l_part_hist.part_no,l_part_hist.owner);
          delete_undeliver(l_part_hist.part_no,l_part_hist.owner);

          -- delete parent pool record
          delete_pool(l_part_hist.part_no,l_part_hist.owner);
 
          -- this is where the COMMIT should be. Currently running in test mode
          -- COMMIT;  **testing
          
          l_cursor_loops := l_cursor_loops + 1;
       
        END IF; -- p_read_only_mode
        
        -- check if time has expired
        check_time_expired;
  
  
      EXCEPTION 
        WHEN e_delete_error THEN
        
          l_pool_errors := l_pool_errors + 1;
          report_error(l_part_hist.part_no,l_part_hist.owner);
          ROLLBACK;
        WHEN e_timeout THEN  
          EXIT;
       
      END;
    
    END LOOP;
 
    -- gather post-hk row counts
    row_counts('POST');
    
    -- write table row counts
    write_child_rowcounts;
      
    IF NOT l_time_expired THEN
   
      -- pool parent deletions
      parent_delete_trial;
      parent_delete_unique_pool;
   
 
    END IF;
    
    
    
    
    -- delete from stand alone tables
    
    -- each one will independantly commit or rollback and report to log file/error log
    -- timeout is checked in each procedure and propegates exception back out 

    BEGIN
      IF NOT l_time_expired THEN

        utl_file.put_line(l_file,' ',TRUE); 
        utl_file.put_line(l_file,'Row Counts for STAND ALONE tables',TRUE); 
        utl_file.put_line(l_file,'Table,Deleted,Start Time,End Time',TRUE); 
      
        delete_sa_abaccus;
        delete_sa_aramis_payments;
        delete_sa_attendance;
        delete_sa_content_store;
        delete_sa_error_log;
        delete_sa_holidays;
        delete_sa_module_machine_xref;
        delete_sa_pl_xml_status;
        delete_sa_print_files;
        delete_sa_peak_usage;
        delete_sa_coroner;
        
    
      END IF;
    EXCEPTION 
      WHEN e_timeout THEN
        null;
    END;
 
    IF l_time_expired THEN
      write_footer(6);
    ELSE  
      write_footer(0);
    END IF;
      
    close_log;
   
    -- remove after development
    ROLLBACK; 
 
 

    -- success
    RETURN 0;
 
  EXCEPTION 

         
    WHEN e_log_error THEN
 
      -- problem with log file
      RETURN 3;
 
    WHEN e_param_error THEN
 
      -- problem with parameter table

      utl_file.put_line(l_file,'RETURN CODE 4 : Missing Parameters' ,TRUE);
    
      utl_file.fclose(l_file);
      RETURN 4;
      
    WHEN e_max_deletions THEN

      utl_file.put_line(l_file,'RETURN CODE 5 : Maximum Deletions' ,TRUE);
    
      utl_file.fclose(l_file);
      RETURN 5;
      
     WHEN others THEN  

      -- unspecified fatal error
      RETURN 2;
      
  END initiate_run;    
    
     
END Housekeeping_NoCommit;
