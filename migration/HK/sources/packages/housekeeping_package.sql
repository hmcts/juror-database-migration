-- Generated by Ora2Pg, the Oracle database Schema converter, version 24.0
-- Copyright 2000-2023 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=172.17.0.2;sid=xe;port=1521

SET client_encoding TO 'UTF8';

SET search_path = hk,public;
\set ON_ERROR_STOP ON

CREATE OR REPLACE PACKAGE Housekeeping IS

/*********************************************************
*  Author  : David Field
*  Created : 5/9/2013 10:45:20 AM
*  Purpose : Housekeeping
*  
*   Change History
*
*   Date    Author     Description
*   ----    ------     -----------
*
********************************************************/
  
  -- Public function and procedure declarations
  FUNCTION initiate_run (p_owner_restrict       VARCHAR2 
                        ,p_read_only_mode       BOOLEAN 
                        ,p_max_time             INTEGER) 
                        RETURN number;
  

END Housekeeping;



CREATE OR REPLACE PACKAGE BODY Housekeeping IS

/*********************************************************
*  Author  : David Field
*  Created : 5/9/2013 10:45:20 AM
*  Purpose : Housekeeping
*  
*   Change History
*
*   Ver  Date     Author     Description
*   ---  ----     ------     -----------
*   1    07.08.13 D Field    Put commits in.
*   2    09.08.13 D Field    Changes cursor c_part_hist for performance.
*   3    16.08.13 D Field    Fixes to the log file.
*   4    06.09.13 D Field    Changes to read only mode.
*   5    10.09.13 D Field    Extra table counts for SA and pool parent tables
*   6    12.09.13 D Field    Now reports SA and pool parents table counts AFTER rollback
********************************************************/
 
  
  FUNCTION initiate_run (p_owner_restrict       VARCHAR2 
                        ,p_read_only_mode       BOOLEAN 
                        ,p_max_time             INTEGER)
                         RETURN number IS
  
    -- main cursor used to select parent records for deletion
    CURSOR c_part_hist(b_court_thresh  INTEGER
                      ,b_bureau_thresh INTEGER
                      ) IS
      SELECT part_no
      ,      owner
      ,      MAX(date_part) maxdate
      FROM   part_hist         ph
      ,      hk_owner_restrict res
      WHERE  ph.owner = res.id
      AND    (p_owner_restrict='NO' OR res.value = 'YES')
      GROUP BY part_no
      ,        owner
      HAVING MAX(date_part) + DECODE(owner,400,b_bureau_thresh,b_court_thresh) < sysdate;

      
    -- A duplicate of the above cursor, but in a count(*) format to check number of 
    -- candidate records  
    CURSOR c_part_hist_count(b_court_thresh  INTEGER
                            ,b_bureau_thresh INTEGER
                            ) IS
      SELECT COUNT(*)
      FROM  (SELECT 1
      FROM   part_hist         ph
      ,      hk_owner_restrict res
      WHERE  ph.owner = res.id
      AND    (p_owner_restrict='NO' OR res.value = 'YES')
      GROUP BY part_no
      ,        owner
      HAVING MAX(date_part) + DECODE(owner,400,b_bureau_thresh,b_court_thresh) < sysdate
             );

      
      -- used for logging functionality
      e_log_error    EXCEPTION; 
      l_file         utl_file.file_type; 
      l_cursor_loops INTEGER := 0;
      l_seq          INTEGER;
      
      -- used for the child rowcounts

      TYPE logs IS TABLE OF number INDEX BY VARCHAR2(4);

      -- main juror tables
      l_defer_dbf        logs; 
      l_part_hist        logs;
      l_part_expenses    logs;
      l_audit_report     logs;   
      l_cert_lett        logs;   
      l_disq_lett        logs;   
      l_manuals          logs;   
      l_audit_f_report   logs;   
      l_appearances      logs;   
      l_confirm_lett     logs;   
      l_part_amendments  logs;   
      l_def_lett         logs;    
      l_def_denied       logs;   
      l_exc_denied_lett  logs;    
      l_postpone_lett    logs;    
      l_fta_lett         logs;   
      l_request_lett     logs;   
      l_phone_log        logs;    
      l_exc_lett         logs;    
      l_undeliver        logs;    
      l_pool             logs;
      l_panel            logs;   

      -- Pool parent tables
      l_accused          logs;
      l_trial            logs;
      l_pool_comments    logs;
      l_pool_stats       logs;
      l_pool_hist        logs;
      l_unique_pool      logs;
      
      -- Stand alone tables
      l_delete_sa_abaccus   logs;
      l_aramis_payments     logs;
      l_attendance          logs;
      l_content_store       logs;
      l_error_log           logs;
      l_holidays            logs;
      l_module_machine_xref logs;
      l_pl_xml_status       logs;
      l_print_files         logs;
      l_peak_usage          logs;
      l_coroner_pool        logs;
      l_coroner_pool_detail logs;
      
      -- used for error handling
      l_error_stage    VARCHAR2(30);
      e_delete_error   EXCEPTION;
      l_err_msg        VARCHAR2(200);
      e_param_error    EXCEPTION;
      e_max_deletions  EXCEPTION;
      l_pool_errors    INTEGER := 0;
       
      -- time out vars
      l_start_time     DATE    := SYSDATE;  -- time proc started 
      l_time_expired   BOOLEAN := false;    -- has the time expired ?
      e_timeout        EXCEPTION;
      
      -- table parameters
      l_param_court_threshold  INTEGER;
      l_param_bureau_threshold INTEGER;
      l_param_max_deletes      INTEGER;
      
      -- misc
      l_part_count INTEGER;
 
   -----------
   --
   -----------

    PROCEDURE write_params_to_log IS
 
      -- Opens up log file and writes header into
  
     
      CURSOR c_hk_owner_restrict IS
        SELECT id
        ,      description
        FROM   hk_owner_restrict
        WHERE  upper(value) = 'YES';
        
  
    BEGIN
 
      utl_file.put_line(l_file,'Parameter P_OWNER_RESTRICT      ,'||p_owner_restrict,TRUE);
      utl_file.put_line(l_file,'Parameter P_COURT_AGE_THRESHOLD ,'||l_param_court_threshold,TRUE);
      utl_file.put_line(l_file,'Parameter P_BUREAU_AGE_THRESHOLD,'||l_param_bureau_threshold,TRUE);
      IF p_read_only_mode THEN
        utl_file.put_line(l_file,'Parameter P_READ_ONLY_MODE      ,TRUE',TRUE);
      ELSIF NOT p_read_only_mode THEN
        utl_file.put_line(l_file,'Parameter P_READ_ONLY_MODE      ,FALSE',TRUE);
      ELSE
        utl_file.put_line(l_file,'Parameter P_READ_ONLY_MODE      ,',TRUE);
      END IF;
      utl_file.put_line(l_file,'Parameter P_MAX_TIME            ,'||p_max_time,TRUE);
      utl_file.put_line(l_file,'Parameter P_MAX_DELETES         ,'||l_param_max_deletes,TRUE);

      IF p_owner_restrict = 'YES' THEN

        utl_file.put_line(l_file,'Courts included ',TRUE); 
        FOR l IN c_hk_owner_restrict LOOP
          utl_file.put_line(l_file,l.id||','||l.description,TRUE);
        END LOOP;
      
      END IF;
 
        
    EXCEPTION 
      WHEN OTHERS THEN
    
        RAISE e_log_error;
       
    END write_params_to_log;

   -----------
   --
   -----------

      
   PROCEDURE fetch_parameters IS
   
     -- Get parameters from main param table. There must be three values - if any are not present then
     -- raise e_param_error execpetion which is handled in main block
   
     CURSOR c_hk_params IS
       SELECT key
       ,      value
       FROM   hk_params;
   
   BEGIN
   
  
     FOR l_hk_params IN c_hk_params LOOP
     
       IF l_hk_params.key = 1 THEN
         l_param_court_threshold := l_hk_params.value;
       ELSIF l_hk_params.key = 2 THEN
         l_param_bureau_threshold := l_hk_params.value;
       ELSIF l_hk_params.key = 3 THEN
         l_param_max_deletes := l_hk_params.value;
       END IF;
     END LOOP;
     
     write_params_to_log;

     -- raise error if database stored parameters are not all present
     IF l_param_court_threshold IS NULL OR l_param_bureau_threshold IS NULL OR l_param_max_deletes IS NULL THEN
       RAISE e_param_error;
     END IF;

     -- raise error if command line parameters are not all present
     IF p_owner_restrict IS NULL OR        
        p_read_only_mode IS NULL OR       
        p_max_time       IS NULL OR
        p_owner_restrict NOT IN ('YES','NO') OR
        NOT p_max_time > 0 THEN
        
        RAISE e_param_error;
        
     END IF;      
 
     
   EXCEPTION
     WHEN others THEN
       RAISE e_param_error;
 
   END fetch_parameters;
 
   -----------
   --
   -----------

    PROCEDURE initate_log IS
 
      -- Opens up log file and writes header into
  
      l_filename VARCHAR2(50);
      
    BEGIN
 
      l_filename := 'HK_run_'||TO_CHAR(sysdate,'dd-mon-yyyy_hh24:mi');
  
      l_file := utl_file.fopen('HK_LOG_DIR',l_filename,'w');
   
      utl_file.put_line(l_file,'HK Run started on '||TO_CHAR(sysdate,'dd-mon-yyyy hh24:mi:ss'),TRUE);

     
    EXCEPTION 
      WHEN OTHERS THEN
    
        RAISE e_log_error;
       
    END initate_log;

   -----------
   --
   -----------


   
   PROCEDURE close_log IS
   
   BEGIN

     utl_file.fclose(l_file); 
    
   EXCEPTION 
     WHEN OTHERS THEN
      
       -- error return code
         RAISE e_log_error;
 
   END close_log;
    
   -----------
   --
   -----------
 
   PROCEDURE record_internal_log_start IS
   
  
   BEGIN
   
     SELECT NVL(MAX(seq_id),1) + 1
     INTO   l_seq
     FROM   hk_run_log;
     
   
     INSERT INTO hk_run_log
     (seq_id
     ,start_time
     )
     VALUES
     (l_seq
     ,SYSDATE
     );
     
     COMMIT;
     
   END record_internal_log_start;
   
   
   -----------
   --
   -----------

  
  
    PROCEDURE write_child_rowcounts IS
 
      -- writes results log and closes file
  
      BEGIN
  
      utl_file.put_line(l_file,' ',TRUE); 
      utl_file.put_line(l_file,'Row Counts for POOL child tables',TRUE); 
      utl_file.put_line(l_file,'Table,Before,After,Deleted',TRUE); 
      utl_file.put_line(l_file,'AUDIT_F_REPORT,'||l_audit_f_report('PRE')||','||l_audit_f_report('POST')||','||(l_audit_f_report('PRE')-l_audit_f_report('POST')),TRUE);
      utl_file.put_line(l_file,'APPEARANCES,'||l_appearances('PRE')||','||l_appearances('POST')||','||(l_appearances('PRE')-l_appearances('POST')),TRUE);
      utl_file.put_line(l_file,'AUDIT_REPORT,'||l_audit_report('PRE')||','||l_audit_report('POST')||','||(l_audit_report('PRE')-l_audit_report('POST')),TRUE);
      utl_file.put_line(l_file,'CERT_LETT,'||l_cert_lett('PRE')||','||l_cert_lett('POST')||','||(l_cert_lett('PRE')-l_cert_lett('POST')),TRUE);
      utl_file.put_line(l_file,'CONFIRM_LETT,'||l_confirm_lett('PRE')||','||l_confirm_lett('POST')||','||(l_confirm_lett('PRE')-l_confirm_lett('POST')),TRUE);
      utl_file.put_line(l_file,'DISQ_LETT,'||l_disq_lett('PRE')||','||l_disq_lett('POST')||','||(l_disq_lett('PRE')-l_disq_lett('POST')),TRUE);
      utl_file.put_line(l_file,'DEFER_DBF,'||l_defer_dbf('PRE')||','||l_defer_dbf('POST')||','||(l_defer_dbf('PRE')-l_defer_dbf('POST')),TRUE);
      utl_file.put_line(l_file,'DEF_LETT,'||l_def_lett('PRE')||','||l_def_lett('POST')||','||(l_def_lett('PRE')-l_def_lett('POST')),TRUE);
      utl_file.put_line(l_file,'DEF_DENIED,'||l_def_denied('PRE')||','||l_def_denied('POST')||','||(l_def_denied('PRE')-l_def_denied('POST')),TRUE);
      utl_file.put_line(l_file,'EXC_LETT,'||l_exc_lett('PRE')||','||l_exc_lett('POST')||','||(l_exc_lett('PRE')-l_exc_lett('POST')),TRUE);
      utl_file.put_line(l_file,'EXC_DENIED_LETT,'||l_exc_denied_lett('PRE')||','||l_exc_denied_lett('POST')||','||(l_exc_denied_lett('PRE')-l_exc_denied_lett('POST')),TRUE);
      utl_file.put_line(l_file,'FTA_LETT,'||l_fta_lett('PRE')||','||l_fta_lett('POST')||','||(l_fta_lett('PRE')-l_fta_lett('POST')),TRUE);
      utl_file.put_line(l_file,'MANUALS,'||l_manuals('PRE')||','||l_manuals('POST')||','||(l_manuals('PRE')-l_manuals('POST')),TRUE);
      utl_file.put_line(l_file,'PANEL,'||l_panel('PRE')||','||l_panel('POST')||','||(l_panel('PRE')-l_panel('POST')),TRUE);
      utl_file.put_line(l_file,'PART_AMENDMENTS,'||l_part_amendments('PRE')||','||l_part_amendments('POST')||','||(l_part_amendments('PRE')-l_part_amendments('POST')),TRUE);
      utl_file.put_line(l_file,'PART_HIST,'||l_part_hist('PRE')||','||l_part_hist('POST')||','||(l_part_hist('PRE')-l_part_hist('POST')),TRUE);
      utl_file.put_line(l_file,'PART_EXPENSES,'||l_part_expenses('PRE')||','||l_part_expenses('POST')||','||(l_part_expenses('PRE')-l_part_expenses('POST')),TRUE);
      utl_file.put_line(l_file,'POSTPONE_LETT,'||l_postpone_lett('PRE')||','||l_postpone_lett('POST')||','||(l_postpone_lett('PRE')-l_postpone_lett('POST')),TRUE);
      utl_file.put_line(l_file,'PHONE_LOG,'||l_phone_log('PRE')||','||l_phone_log('POST')||','||(l_phone_log('PRE')-l_phone_log('POST')),TRUE);
      utl_file.put_line(l_file,'REQUEST_LETT,'||l_request_lett('PRE')||','||l_request_lett('POST')||','||(l_request_lett('PRE')-l_request_lett('POST')),TRUE);
      utl_file.put_line(l_file,'UNDELIVR,'||l_undeliver('PRE')||','||l_undeliver('POST')||','||(l_undeliver('PRE')-l_undeliver('POST')),TRUE);
      utl_file.put_line(l_file,' ',TRUE); 
      utl_file.put_line(l_file,'Row Counts for POOL table',TRUE); 
      utl_file.put_line(l_file,'Table,Before,After,Deleted',TRUE); 
      utl_file.put_line(l_file,'POOL,'||l_pool('PRE')||','||l_pool('POST')||','||(l_pool('PRE')-l_pool('POST')),TRUE);


       
    EXCEPTION 
      WHEN OTHERS THEN
      
        RAISE e_log_error;
      
    END write_child_rowcounts;

   -----------
   --
   -----------

   PROCEDURE write_footer (p_code INTEGER) IS
   
   BEGIN

     utl_file.put_line(l_file,' ',TRUE); 
     utl_file.put_line(l_file,'No. of Juror selected for deletion ,'||l_part_count,TRUE);
     utl_file.put_line(l_file,'No. of Juror successfully deleted  ,'||l_cursor_loops,TRUE);
     utl_file.put_line(l_file,'No. of failures                    ,'||l_pool_errors,TRUE);

     IF p_code = 0 THEN
       utl_file.put_line(l_file,'Return Code 0 : Success',TRUE);
     ELSIF p_code = 1 THEN
       utl_file.put_line(l_file,'Return Code 1 : POOL errors raised',TRUE);
     ELSIF p_code = 2 THEN
       utl_file.put_line(l_file,'Return Code 2 : Fatal Error',TRUE);
     ELSIF p_code = 3 THEN
       utl_file.put_line(l_file,'Return Code 3 : Log File Error',TRUE);
     ELSIF p_code = 4 THEN
       utl_file.put_line(l_file,'Return Code 4 : Parameter Error',TRUE);
     ELSIF p_code = 5 THEN
       utl_file.put_line(l_file,'Return Code 5 : Max Deletions Limit',TRUE);
     ELSIF p_code = 6 THEN
       utl_file.put_line(l_file,'Return Code 6 : Timeout',TRUE);
     ELSE  
       utl_file.put_line(l_file,'Unknow Return Code',TRUE);
     END IF;  
     
     
     
     UPDATE hk_run_log
     SET    end_time       = SYSDATE
     ,      return_code    = p_code
     ,      jurors_deleted = l_cursor_loops
     ,      jurors_error   = l_pool_errors
     WHERE  seq_id = l_seq;
     
     COMMIT;
      
   END write_footer;

   -----------
   --
   -----------   

    PROCEDURE row_counts_juror (p_stage VARCHAR2) IS
    
    BEGIN
    
        SELECT COUNT(*) INTO l_part_hist(p_stage)       FROM part_hist;
        SELECT COUNT(*) INTO l_part_expenses(p_stage)   FROM part_expenses;
        SELECT COUNT(*) INTO l_audit_report(p_stage)    FROM audit_report;
        SELECT COUNT(*) INTO l_cert_lett(p_stage)       FROM cert_lett;
        SELECT COUNT(*) INTO l_disq_lett(p_stage)       FROM disq_lett;
        SELECT COUNT(*) INTO l_manuals(p_stage)         FROM manuals;
        SELECT COUNT(*) INTO l_audit_f_report(p_stage)  FROM audit_f_report;
        SELECT COUNT(*) INTO l_appearances(p_stage)     FROM appearances;
        SELECT COUNT(*) INTO l_confirm_lett(p_stage)    FROM confirm_lett;
        SELECT COUNT(*) INTO l_part_amendments(p_stage) FROM part_amendments;
        SELECT COUNT(*) INTO l_def_lett(p_stage)        FROM def_lett;
        SELECT COUNT(*) INTO l_def_denied(p_stage)      FROM def_denied;
        SELECT COUNT(*) INTO l_exc_denied_lett(p_stage) FROM exc_denied_lett;
        SELECT COUNT(*) INTO l_postpone_lett(p_stage)   FROM postpone_lett;
        SELECT COUNT(*) INTO l_fta_lett(p_stage)        FROM fta_lett;
        SELECT COUNT(*) INTO l_request_lett(p_stage)    FROM request_lett;
        SELECT COUNT(*) INTO l_phone_log(p_stage)       FROM phone_log;
        SELECT COUNT(*) INTO l_exc_lett(p_stage)        FROM exc_lett;
        SELECT COUNT(*) INTO l_undeliver(p_stage)       FROM undelivr;
        SELECT COUNT(*) INTO l_pool(p_stage)            FROM pool;
        SELECT COUNT(*) INTO l_panel(p_stage)           FROM panel;
        SELECT COUNT(*) INTO l_defer_dbf(p_stage)       FROM defer_dbf;
      
    END row_counts_juror;
  
   -----------
   --
   -----------
 
   PROCEDURE check_time_expired IS
   
     -- parameter p_max_time is the value in minutes for the maximum
     -- time the HK process should run for
   
   BEGIN
   
      IF l_start_time + (( 1/24/60 ) * p_max_time) > sysdate THEN
        l_time_expired := false;
      ELSE
        l_time_expired := true;  
        utl_file.put_line(l_file,'*** TIME EXPIRED AT '||TO_CHAR(sysdate,'dd-mon-yyyy hh24:mi'),TRUE);
        RAISE e_timeout;
      END IF;
   
   END check_time_expired;

   -----------
   --
   -----------
   
   PROCEDURE delete_audit_report(p_part_no VARCHAR, p_owner VARCHAR) IS
   
   
   BEGIN
   
     l_error_stage := 'AUDIT_REPORT';
    
     DELETE audit_report
     WHERE  owner = p_owner
     AND    part_no = p_part_no;
 
     utl_file.put(l_file,SQL%ROWCOUNT||',');

     l_error_stage := 'AUDIT_F_REPORT';

     DELETE audit_f_report
     WHERE  owner = p_owner
     AND    part_no = p_part_no;
 
     utl_file.put(l_file,SQL%ROWCOUNT||',');

      
   EXCEPTION 
     WHEN others THEN
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       RAISE e_delete_error; 
 
   END delete_audit_report;
 
   -----------
   --
   -----------
 
   
   PROCEDURE delete_part_hist(p_part_no VARCHAR, p_owner VARCHAR) IS
   
   BEGIN
   
     l_error_stage := 'PART_HIST';
    
     DELETE part_hist
     WHERE  owner = p_owner
     AND    part_no = p_part_no;
     
     utl_file.put(l_file,SQL%ROWCOUNT||',');

      
   EXCEPTION 
     WHEN others THEN
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       RAISE e_delete_error; 
 
   END delete_part_hist;
 
   -----------
   --
   -----------
 
   PROCEDURE delete_part_expenses(p_part_no VARCHAR, p_owner VARCHAR) IS
   
   
   BEGIN
   
     l_error_stage := 'PART_EXPENSES';

    
     DELETE part_expenses
     WHERE  owner = p_owner
     AND    part_no = p_part_no;
  
     utl_file.put(l_file,SQL%ROWCOUNT||',');

     l_error_stage := 'APPEARANCES';
    
     DELETE appearances
     WHERE  owner = p_owner
     AND    part_no = p_part_no;

     utl_file.put(l_file,SQL%ROWCOUNT||',');

      
   EXCEPTION 
     WHEN others THEN
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       RAISE e_delete_error; 
 
   END delete_part_expenses;
 
   -----------
   --
   -----------
 
   PROCEDURE delete_cert_lett(p_part_no VARCHAR, p_owner VARCHAR) IS
   
   
   BEGIN
   
     l_error_stage := 'CERT_LETT';
    
     DELETE cert_lett
     WHERE  owner = p_owner
     AND    part_no = p_part_no;

     utl_file.put(l_file,SQL%ROWCOUNT||',');
      
   EXCEPTION 
     WHEN others THEN
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       RAISE e_delete_error; 
 
   END delete_cert_lett;
 
   -----------
   --
   -----------
  
   PROCEDURE delete_disq_lett(p_part_no VARCHAR, p_owner VARCHAR) IS
   
   
   BEGIN
   
     l_error_stage := 'DISQ_LETT';
    
     DELETE disq_lett
     WHERE  owner = p_owner
     AND    part_no = p_part_no;
      
     utl_file.put(l_file,SQL%ROWCOUNT||',');
 
   EXCEPTION 
     WHEN others THEN
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       RAISE e_delete_error; 
 
   END delete_disq_lett;
 
   -----------
   --
   -----------
  
   PROCEDURE delete_manuals(p_part_no VARCHAR, p_owner VARCHAR) IS
   
   
   BEGIN
   
     l_error_stage := 'MANUALS';
    
     DELETE manuals
     WHERE  owner = p_owner
     AND    part_no = p_part_no;
   
     utl_file.put(l_file,SQL%ROWCOUNT||',');
      
   EXCEPTION 
     WHEN others THEN
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       RAISE e_delete_error; 
 
   END delete_manuals;
 
   -----------
   --
   -----------
   
   PROCEDURE delete_confirm_lett(p_part_no VARCHAR, p_owner VARCHAR) IS
   
   
   BEGIN
   
     l_error_stage := 'CONFIRM_LETT';
    
     DELETE confirm_lett
     WHERE  owner = p_owner
     AND    part_no = p_part_no;
 
     utl_file.put(l_file,SQL%ROWCOUNT||',');
      
   EXCEPTION 
     WHEN others THEN
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       RAISE e_delete_error; 
 
   END delete_confirm_lett;
 
   -----------
   --
   -----------
 
   PROCEDURE delete_part_amendments(p_part_no VARCHAR, p_owner VARCHAR) IS
   
   
   BEGIN
   
     l_error_stage := 'PART_AMENDMENTS';
    
     DELETE part_amendments
     WHERE  owner = p_owner
     AND    part_no = p_part_no;
 
     utl_file.put(l_file,SQL%ROWCOUNT||',');
       
   EXCEPTION 
     WHEN others THEN
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       RAISE e_delete_error; 
 
   END delete_part_amendments;
 
   -----------
   --
   -----------
   PROCEDURE delete_exc_denied_lett(p_part_no VARCHAR, p_owner VARCHAR) IS
   
   BEGIN
   
     l_error_stage := 'exc_denied_lett';
    
     DELETE exc_denied_lett
     WHERE  owner = p_owner
     AND    part_no = p_part_no;

     utl_file.put(l_file,SQL%ROWCOUNT||',');
      
   EXCEPTION 
     WHEN others THEN
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       RAISE e_delete_error; 
 
   END delete_exc_denied_lett;
 
   -----------
   --
   -----------

   PROCEDURE delete_def_lett(p_part_no VARCHAR, p_owner VARCHAR) IS
   
   BEGIN
   
     l_error_stage := 'def_lett';
    
     DELETE def_lett
     WHERE  owner = p_owner
     AND    part_no = p_part_no;

     utl_file.put(l_file,SQL%ROWCOUNT||',');
      
   EXCEPTION 
     WHEN others THEN
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       RAISE e_delete_error; 
 
   END delete_def_lett;
 
   -----------
   --
   -----------
 
   PROCEDURE delete_def_denied(p_part_no VARCHAR, p_owner VARCHAR) IS
   
   BEGIN
   
     l_error_stage := 'def_denied';
    
     DELETE def_denied
     WHERE  owner = p_owner
     AND    part_no = p_part_no;
 
     utl_file.put(l_file,SQL%ROWCOUNT||',');
      
   EXCEPTION 
     WHEN others THEN
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       RAISE e_delete_error; 
 
   END delete_def_denied;
 
   -----------
   --
   -----------

   PROCEDURE delete_defer_dbf(p_part_no VARCHAR, p_owner VARCHAR) IS
   
   BEGIN
   
     l_error_stage := 'defer_dbf';
    
     DELETE defer_dbf
     WHERE  owner = p_owner
     AND    part_no = p_part_no;

     utl_file.put(l_file,SQL%ROWCOUNT||',' );
      
   EXCEPTION 
     WHEN others THEN
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       RAISE e_delete_error; 
 
   END delete_defer_dbf;
 
   -----------
   --
   -----------


   PROCEDURE delete_undeliver(p_part_no VARCHAR, p_owner VARCHAR) IS
   
   BEGIN
   
     l_error_stage := 'undeliver';
    
     DELETE undelivr
     WHERE  owner = p_owner
     AND    part_no = p_part_no;

     utl_file.put(l_file,SQL%ROWCOUNT||',');
       
   EXCEPTION 
     WHEN others THEN
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       RAISE e_delete_error; 
 
   END delete_undeliver;
 
   -----------
   --
   -----------

   PROCEDURE delete_exc_lett(p_part_no VARCHAR, p_owner VARCHAR) IS
   
   
   BEGIN
   
     l_error_stage := 'exc_lett';
  
     DELETE exc_lett
     WHERE  owner = p_owner
     AND    part_no = p_part_no;

     utl_file.put(l_file,SQL%ROWCOUNT||',');
      
   EXCEPTION 
     WHEN others THEN
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       RAISE e_delete_error; 
 
   END delete_exc_lett;
 
   -----------
   --
   -----------

   PROCEDURE delete_phone_log(p_part_no VARCHAR, p_owner VARCHAR) IS
   
   BEGIN
   
     l_error_stage := 'phone_log';
    
     DELETE phone_log
     WHERE  owner = p_owner
     AND    part_no = p_part_no;

     utl_file.put(l_file,SQL%ROWCOUNT||',');
      
   EXCEPTION 
     WHEN others THEN
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       RAISE e_delete_error; 
 
   END delete_phone_log;
 
   -----------
   --
   -----------

   PROCEDURE delete_request_lett(p_part_no VARCHAR, p_owner VARCHAR) IS
   
   BEGIN
   
     l_error_stage := 'request_lett';
    
     DELETE request_lett
     WHERE  owner = p_owner
     AND    part_no = p_part_no;
 
     utl_file.put(l_file,SQL%ROWCOUNT||',' );
      
   EXCEPTION 
     WHEN others THEN
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       RAISE e_delete_error; 
 
   END delete_request_lett;
 
   -----------
   --
   -----------

   PROCEDURE delete_fta_lett(p_part_no VARCHAR, p_owner VARCHAR) IS
   
   BEGIN
   
     l_error_stage := 'fta_lett';
    
     DELETE fta_lett
     WHERE  owner = p_owner
     AND    part_no = p_part_no;
 
     utl_file.put(l_file,SQL%ROWCOUNT||',');
      
   EXCEPTION 
     WHEN others THEN
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       RAISE e_delete_error; 
 
   END delete_fta_lett;
 
   -----------
   --
   -----------

   PROCEDURE delete_postpone_lett(p_part_no VARCHAR, p_owner VARCHAR) IS
   
   BEGIN
   
     l_error_stage := 'postpone_lett';
    
     DELETE postpone_lett
     WHERE  owner = p_owner
     AND    part_no = p_part_no;

     utl_file.put(l_file,SQL%ROWCOUNT||',');
      
   EXCEPTION 
     WHEN others THEN
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       RAISE e_delete_error; 
 
   END delete_postpone_lett;
 
   -----------
   --
   -----------

   PROCEDURE delete_pool(p_part_no VARCHAR, p_owner VARCHAR) IS
   
   BEGIN
   
     l_error_stage := 'pool';
    
     DELETE pool
     WHERE  owner = p_owner
     AND    part_no = p_part_no;

     utl_file.put_line(l_file,SQL%ROWCOUNT ,TRUE);
      
   EXCEPTION 
     WHEN others THEN
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       RAISE e_delete_error; 
 
   END delete_pool;
 
   -----------
   --
   -----------

   PROCEDURE delete_panel (p_part_no VARCHAR, p_owner VARCHAR) IS 
   
   BEGIN
   
     l_error_stage := 'PANEL';
    
     DELETE panel
     WHERE  owner = p_owner
     AND    part_no = p_part_no;
 
     utl_file.put(l_file,SQL%ROWCOUNT||',');
       
   EXCEPTION 
     WHEN others THEN
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       RAISE e_delete_error; 
 
   END delete_panel;
   
   -----------
   --
   -----------

   PROCEDURE delete_sa_abaccus IS 
   
     l_start DATE;
     l_deleted NUMBER;
   
   BEGIN
    
     l_start := SYSDATE;

     SELECT COUNT(*) INTO l_delete_sa_abaccus('PRE') FROM abaccus;
    
     DELETE abaccus
     WHERE  creation_date + l_param_bureau_threshold < SYSDATE; 

     l_deleted := SQL%ROWCOUNT;
      
     IF p_read_only_mode THEN
       ROLLBACK;
     ELSE
       COMMIT;  
     END IF;
     
     SELECT COUNT(*) INTO l_delete_sa_abaccus('POST') FROM abaccus;

     utl_file.put_line(l_file,'ABACCUS,'||l_deleted||','||TO_CHAR(l_start,'DD-MM-YYYY hh24:MI:SS')||','||TO_CHAR(sysdate,'DD-MM-YYYY hh24:MI:SS')||','||l_delete_sa_abaccus('PRE')||','||l_delete_sa_abaccus('POST')||','||TO_CHAR(l_delete_sa_abaccus('PRE')-l_delete_sa_abaccus('POST')),TRUE);
  
     check_time_expired;
       
   EXCEPTION 
     WHEN e_timeout THEN
       raise e_timeout;

     WHEN others THEN
     
       ROLLBACK;
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       utl_file.put_line(l_file,'ERROR Delete from ABACCUS',TRUE);
       utl_file.put_line(l_file,l_err_msg,TRUE);
 
   END delete_sa_abaccus;
   
   -----------
   --
   -----------

   PROCEDURE delete_sa_attendance IS 
  
     l_start DATE;
     l_deleted NUMBER;
   
   BEGIN
    
     l_start := SYSDATE;

     SELECT COUNT(*) INTO l_attendance('PRE') FROM attendance;
 
     DELETE attendance
     WHERE  month_start + l_param_court_threshold < SYSDATE; 

     l_deleted := SQL%ROWCOUNT;

      IF p_read_only_mode THEN
        ROLLBACK;
      ELSE
         COMMIT;  
      END IF;
  
     SELECT COUNT(*) INTO l_attendance('POST') FROM attendance;

     utl_file.put_line(l_file,'ATTENDANCE,'||l_deleted||','||TO_CHAR(l_start,'DD-MM-YYYY hh24:MI:SS')||','||TO_CHAR(sysdate,'DD-MM-YYYY hh24:MI:SS')||','||l_attendance('PRE')||','||l_attendance('POST')||','||TO_CHAR(l_attendance('PRE')-l_attendance('POST')),TRUE);
    
     
     check_time_expired;
       
   EXCEPTION 
     WHEN e_timeout THEN
       raise e_timeout;

     WHEN others THEN
   
       ROLLBACK;
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       utl_file.put_line(l_file,'ERROR Delete from ATTENDANCE',TRUE);
       utl_file.put_line(l_file,l_err_msg,TRUE);
 
   END delete_sa_attendAnce;
   
   -----------
   --
   -----------

   PROCEDURE delete_sa_content_store IS 

    l_start DATE;
    l_deleted NUMBER;

   BEGIN
    
     l_start := SYSDATE;

     SELECT COUNT(*) INTO l_content_store('PRE') FROM content_store;

     DELETE content_store
     WHERE  date_on_q_for_send + l_param_court_threshold < SYSDATE; 

     l_deleted := SQL%ROWCOUNT;

     IF p_read_only_mode THEN
        ROLLBACK;
      ELSE
        COMMIT;  
      END IF;

     SELECT COUNT(*) INTO l_content_store('POST') FROM content_store;

     utl_file.put_line(l_file,'CONTENT_STORE,'||l_deleted||','||TO_CHAR(l_start,'DD-MM-YYYY hh24:MI:SS')||','||TO_CHAR(sysdate,'DD-MM-YYYY hh24:MI:SS')||','||l_content_store('PRE')||','||l_content_store('POST')||','||TO_CHAR(l_content_store('PRE')-l_content_store('POST')),TRUE);
      
     check_time_expired;
       
   EXCEPTION 
     WHEN e_timeout THEN
       raise e_timeout;
   
     WHEN others THEN
     
       ROLLBACK;
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       utl_file.put_line(l_file,'ERROR Delete from CONTENT_STORE',TRUE);
       utl_file.put_line(l_file,l_err_msg,TRUE);
 
   END delete_sa_content_store;
   
   -----------
   --
   -----------

   PROCEDURE delete_sa_error_log IS 

    l_start DATE;
    l_deleted NUMBER;
   
   BEGIN
    
     l_start := SYSDATE;

     SELECT COUNT(*) INTO l_error_log('PRE') FROM error_log;

     DELETE error_log
     WHERE  time_stamp + l_param_court_threshold < SYSDATE; 

     l_deleted := SQL%ROWCOUNT;

      IF p_read_only_mode THEN
        ROLLBACK;
      ELSE
         COMMIT; 
      END IF;
     
     SELECT COUNT(*) INTO l_error_log('POST') FROM error_log;
    
     utl_file.put_line(l_file,'ERROR_LOG,'||l_deleted||','||TO_CHAR(l_start,'DD-MM-YYYY hh24:MI:SS')||','||TO_CHAR(sysdate,'DD-MM-YYYY hh24:MI:SS')||','||l_error_log('PRE')||','||l_error_log('POST')||','||TO_CHAR(l_error_log('PRE')-l_error_log('POST')),TRUE);
  
     check_time_expired;
       
   EXCEPTION 
     WHEN e_timeout THEN
       raise e_timeout;
   
     WHEN others THEN
  
       ROLLBACK;
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       utl_file.put_line(l_file,'ERROR Delete from ERROR_LOG',TRUE);
       utl_file.put_line(l_file,l_err_msg,TRUE);
 
   END delete_sa_error_log;

   -----------
   --
   -----------

   PROCEDURE delete_sa_holidays IS 

    l_start DATE;
    l_deleted NUMBER;
   
   BEGIN
    
     l_start := SYSDATE;

     SELECT COUNT(*) INTO l_holidays('PRE') FROM holidays;

     DELETE holidays
     WHERE  holiday + l_param_court_threshold < SYSDATE; 
 
     l_deleted := SQL%ROWCOUNT;
 
     IF p_read_only_mode THEN
       ROLLBACK;
     ELSE
       COMMIT;  
     END IF;
     
     SELECT COUNT(*) INTO l_holidays('POST') FROM holidays;

     utl_file.put_line(l_file,'HOLIDAYS,'||l_deleted||','||TO_CHAR(l_start,'DD-MM-YYYY hh24:MI:SS')||','||TO_CHAR(sysdate,'DD-MM-YYYY hh24:MI:SS')||','||l_holidays('PRE')||','||l_holidays('POST')||','||TO_CHAR(l_holidays('PRE')-l_holidays('POST')),TRUE);
     
     check_time_expired;
       
   EXCEPTION 
     WHEN e_timeout THEN
       raise e_timeout;
   
     WHEN others THEN
 
       ROLLBACK;
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       utl_file.put_line(l_file,'ERROR Delete from HOLIDAYS',TRUE);
       utl_file.put_line(l_file,l_err_msg,TRUE);
 
   END delete_sa_holidays;

   -----------
   --
   -----------

   PROCEDURE delete_sa_print_files IS 

    l_start DATE;
    l_deleted NUMBER;
   
   BEGIN

     l_start := SYSDATE;

     SELECT COUNT(*) INTO l_print_files('PRE') FROM print_files;
   
     DELETE print_files
     WHERE  creation_date + l_param_bureau_threshold < SYSDATE; 

     l_deleted := SQL%ROWCOUNT;

      IF p_read_only_mode THEN
        ROLLBACK;
      ELSE
        COMMIT; 
      END IF;
     
     SELECT COUNT(*) INTO l_print_files('POST') FROM print_files;
     
     utl_file.put_line(l_file,'PRINT_FILES,'||l_deleted||','||TO_CHAR(l_start,'DD-MM-YYYY hh24:MI:SS')||','||TO_CHAR(sysdate,'DD-MM-YYYY hh24:MI:SS')||','||l_print_files('PRE')||','||l_print_files('POST')||','||TO_CHAR(l_print_files('PRE')-l_print_files('POST')),TRUE);
 
     check_time_expired;
       
   EXCEPTION 
     WHEN e_timeout THEN
       raise e_timeout;
   
     WHEN others THEN

       ROLLBACK;
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       utl_file.put_line(l_file,'ERROR Delete from PRINT_FILES',TRUE);
       utl_file.put_line(l_file,l_err_msg,TRUE);
 
   END delete_sa_print_files;

   -----------
   --
   -----------

   PROCEDURE delete_sa_pl_xml_status IS 

    l_start DATE;
    l_deleted NUMBER;
   
   BEGIN
    
     l_start := SYSDATE;

     SELECT COUNT(*) INTO l_pl_xml_status('PRE') FROM pl_xml_status;
     
     DELETE pl_xml_status
     WHERE  date_time_stamp + l_param_court_threshold < SYSDATE; 

     l_deleted := SQL%ROWCOUNT;

     IF p_read_only_mode THEN
       ROLLBACK;
     ELSE
       COMMIT; 
     END IF;
    
     SELECT COUNT(*) INTO l_pl_xml_status('POST') FROM pl_xml_status;

     utl_file.put_line(l_file,'PL_XML_STATUS,'||l_deleted||','||TO_CHAR(l_start,'DD-MM-YYYY hh24:MI:SS')||','||TO_CHAR(sysdate,'DD-MM-YYYY hh24:MI:SS')||','||l_pl_xml_status('PRE')||','||l_pl_xml_status('POST')||','||TO_CHAR(l_pl_xml_status('PRE')-l_pl_xml_status('POST')),TRUE);

      
     check_time_expired;
       
   EXCEPTION 
     WHEN e_timeout THEN
       raise e_timeout;
   
     WHEN others THEN

       ROLLBACK;
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       utl_file.put_line(l_file,'ERROR Delete from PL_XML_STATUS',TRUE);
       utl_file.put_line(l_file,l_err_msg,TRUE);
 
   END delete_sa_pl_xml_status;
   
   -----------
   --
   -----------

   PROCEDURE delete_sa_coroner IS 

     l_start_pool_detail   DATE;
     l_start               DATE;
     l_end                 DATE;
     l_deleted_pool_detail NUMBER;
     l_deleted             NUMBER;
   
   BEGIN

     l_start_pool_detail := SYSDATE;

 
     SELECT COUNT(*) INTO l_coroner_pool_detail('PRE') FROM coroner_pool_detail;
        
     DELETE coroner_pool_detail
     WHERE  cor_pool_no IN (SELECT cor_pool_no
                            FROM   coroner_pool
                            WHERE  cor_service_dt + l_param_bureau_threshold < SYSDATE
                            ); 

     l_deleted_pool_detail := SQL%ROWCOUNT;
                           
     l_start := SYSDATE;

     SELECT COUNT(*) INTO l_coroner_pool('PRE')  FROM coroner_pool;
     
     DELETE coroner_pool
     WHERE  cor_service_dt + l_param_bureau_threshold < SYSDATE;

     l_deleted := SQL%ROWCOUNT;
     l_end     := SYSDATE;
     
     IF p_read_only_mode THEN
       ROLLBACK;
     ELSE
       COMMIT;  
     END IF;

     SELECT COUNT(*) INTO l_coroner_pool_detail('POST') FROM coroner_pool_detail;
    
     SELECT COUNT(*) INTO l_coroner_pool('POST')  FROM coroner_pool;

     utl_file.put_line(l_file,'CORONER_POOL_DETAIL,'||l_deleted_pool_detail||','||TO_CHAR(l_start_pool_detail,'DD-MM-YYYY hh24:MI:SS')||','||TO_CHAR(l_end,'DD-MM-YYYY hh24:MI:SS')||','||l_coroner_pool_detail('PRE')||','||l_coroner_pool_detail('POST')||','||TO_CHAR(l_coroner_pool_detail('PRE')-l_coroner_pool_detail('POST')) ,TRUE);
     utl_file.put_line(l_file,'CORONER_POOL,'||l_deleted||','||TO_CHAR(l_start,'DD-MM-YYYY hh24:MI:SS')||','||TO_CHAR(sysdate,'DD-MM-YYYY hh24:MI:SS')||','||l_coroner_pool('PRE')||','||l_coroner_pool('POST')||','||TO_CHAR(l_coroner_pool('PRE')-l_coroner_pool('POST')),TRUE);
     
     check_time_expired;
       
   EXCEPTION 
     WHEN e_timeout THEN
       raise e_timeout;
   
     WHEN others THEN
     
       ROLLBACK;
  
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       utl_file.put_line(l_file,'ERROR Delete from sa_content',TRUE);
       utl_file.put_line(l_file,l_err_msg,TRUE);
 
   END delete_sa_coroner;
   
     
   -----------
   --
   -----------
 
   PROCEDURE delete_sa_module_machine_xref IS 

    l_start DATE;
    l_deleted NUMBER;
   
   BEGIN
    
     l_start := SYSDATE;

     SELECT COUNT(*) INTO l_module_machine_xref('PRE')  FROM module_machine_xref;
 
     DELETE module_machine_xref
     WHERE  last_update + l_param_court_threshold < SYSDATE; 

     l_deleted := SQL%ROWCOUNT;

     IF p_read_only_mode THEN
        ROLLBACK;
      ELSE
        COMMIT;  
      END IF;
     
     SELECT COUNT(*) INTO l_module_machine_xref('POST')  FROM module_machine_xref;
 
     utl_file.put_line(l_file,'MODULE_MACHINE_XREF,'||l_deleted||','||TO_CHAR(l_start,'DD-MM-YYYY hh24:MI:SS')||','||TO_CHAR(sysdate,'DD-MM-YYYY hh24:MI:SS')||','||l_module_machine_xref('PRE')||','||l_module_machine_xref('POST')||','||TO_CHAR(l_module_machine_xref('PRE')-l_module_machine_xref('POST')),TRUE);
     
     check_time_expired;
       
   EXCEPTION 
     WHEN e_timeout THEN
       raise e_timeout;
   
     WHEN others THEN
 
       ROLLBACK;
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       utl_file.put_line(l_file,'ERROR Delete from MODULE_MACHINE_XREF',TRUE);
       utl_file.put_line(l_file,l_err_msg,TRUE);
 
   END delete_sa_module_machine_xref;


   -----------
   --
   -----------
 
   PROCEDURE delete_sa_peak_usage IS 

    l_start DATE;
    l_deleted NUMBER;
   
   BEGIN

     l_start := SYSDATE;

     SELECT COUNT(*) INTO l_peak_usage('PRE') FROM peak_usage;
    
     DELETE peak_usage
     WHERE  vd_date + l_param_court_threshold < SYSDATE; 

     l_deleted := SQL%ROWCOUNT;

     IF p_read_only_mode THEN
       ROLLBACK;
     ELSE
       COMMIT;  
     END IF;

     SELECT COUNT(*) INTO l_peak_usage('POST') FROM peak_usage;
    
     utl_file.put_line(l_file,'PEAK_USAGE,'||l_deleted||','||TO_CHAR(l_start,'DD-MM-YYYY hh24:MI:SS')||','||TO_CHAR(sysdate,'DD-MM-YYYY hh24:MI:SS')||','||l_peak_usage('PRE')||','||l_peak_usage('POST')||','||TO_CHAR(l_peak_usage('PRE')-l_peak_usage('POST')),TRUE);
     
     check_time_expired;
       
   EXCEPTION 
     WHEN e_timeout THEN
       raise e_timeout;
   
     WHEN others THEN
     
       ROLLBACK;
 
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       utl_file.put_line(l_file,'ERROR Delete from PEAK_USAGE',TRUE);
       utl_file.put_line(l_file,l_err_msg,TRUE);
 
   END delete_sa_peak_usage;   

   -----------
   --
   -----------

   PROCEDURE delete_sa_aramis_payments IS 

     l_start DATE;
     l_deleted NUMBER;
  
   BEGIN

     l_start := SYSDATE;

     SELECT COUNT(*) INTO l_aramis_payments('PRE') FROM aramis_payments;
   
     DELETE aramis_payments
     WHERE  creation_date + l_param_court_threshold < SYSDATE; 

     l_deleted := SQL%ROWCOUNT;

     IF p_read_only_mode THEN
       ROLLBACK;
     ELSE
       COMMIT;  
     END IF;

     SELECT COUNT(*) INTO l_aramis_payments('POST') FROM aramis_payments;
     
     utl_file.put_line(l_file,'ARAMIS_PAYMENTS,'||l_deleted||','||TO_CHAR(l_start,'DD-MM-YYYY hh24:MI:SS')||','||TO_CHAR(sysdate,'DD-MM-YYYY hh24:MI:SS')||','||l_aramis_payments('PRE')||','||l_aramis_payments('POST')||','||TO_CHAR(l_aramis_payments('PRE')-l_aramis_payments('POST')),TRUE);
     
     check_time_expired;
       
   EXCEPTION 
     WHEN e_timeout THEN
       raise e_timeout;
   
     WHEN others THEN
     
       ROLLBACK;
 
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       utl_file.put_line(l_file,'ERROR Delete from ARAMIS_PAYMENTS',TRUE);
       utl_file.put_line(l_file,l_err_msg,TRUE);
 
   END delete_sa_aramis_payments;   


   -----------
   --
   -----------
   
   PROCEDURE parent_delete_trial IS 
   
     l_start DATE;
     l_start_Accused DATE;
     l_deleted NUMBER;
     l_deleted_accused NUMBER;
     l_end   DATE;
     
   BEGIN
   
     l_error_stage := 'ACCUSED';
     l_start_accused := SYSDATE;

     SELECT COUNT(*) INTO l_accused('PRE') FROM accused;
 
     utl_file.put_line(l_file,' ',TRUE); 
     utl_file.put_line(l_file,'Row Counts for POOL PARENT tables',TRUE); 
     utl_file.put_line(l_file,'Table,Selected,Start Time,End Time,Before,After,Deleted',TRUE); 
  
     
     DELETE accused ac
     WHERE  EXISTS (SELECT null 
                    FROM   trial tr
                    WHERE  trial_end_date + l_param_court_threshold < sysdate
                    AND    tr.owner = ac.owner
                    AND    tr.trial_no = ac.trial_no
                    AND NOT EXISTS (SELECT null
                                    FROM   panel pl
                                    WHERE  tr.trial_no = pl.trial_no 
                                    AND    tr.owner = pl.owner
                                    )
                    );
  
     l_deleted_accused := SQL%ROWCOUNT;
     l_end      := SYSDATE;
         
     l_error_stage := 'TRIAL';
     l_start := SYSDATE;
 
     SELECT COUNT(*) INTO l_trial('PRE') FROM trial;
 
     DELETE trial ab
     WHERE  trial_end_date + l_param_court_threshold < sysdate
     AND NOT EXISTS (SELECT null
                     FROM   panel pl
                     WHERE  ab.trial_no = pl.trial_no 
                     AND    ab.owner = pl.owner
                     );

    l_deleted := SQL%ROWCOUNT;
  
     IF p_read_only_mode THEN
       ROLLBACK;
     ELSE
       COMMIT; 
     END IF;
                       
     SELECT COUNT(*) INTO l_accused('POST') FROM accused;
     SELECT COUNT(*) INTO l_trial('POST') FROM trial;

     utl_file.put_line(l_file,'TRIAL,'||l_deleted||','||TO_CHAR(l_start,'DD-MM-YYYY hh24:MI:SS')||','||TO_CHAR(sysdate,'DD-MM-YYYY hh24:MI:SS')||','||l_trial('PRE')||','||l_trial('POST')||','||TO_CHAR(l_trial('PRE')-l_trial('POST')),TRUE);
     utl_file.put_line(l_file,'ACCUSED,'||l_deleted_accused||','||TO_CHAR(l_start_accused,'DD-MM-YYYY hh24:MI:SS')||','||TO_CHAR(l_end,'DD-MM-YYYY hh24:MI:SS')||','||l_accused('PRE')||','||l_accused('POST')||','||TO_CHAR(l_accused('PRE')-l_accused('POST')) ,TRUE);
    
 
   EXCEPTION 
     WHEN others THEN
     
       ROLLBACK;
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
 
       RAISE e_delete_error; 
 
   END parent_delete_trial;
   
   -----------
   --
   -----------
   
   PROCEDURE parent_delete_unique_pool IS
 
     l_start         DATE;
     l_start_stats   DATE;
     l_start_comments DATE;
     l_start_hist       DATE;
     l_deleted          NUMBER;
     l_deleted_comments NUMBER;
     l_deleted_stats    NUMBER;
     l_deleted_hist     NUMBER;
     l_end_comments    DATE;
     l_end_stats       DATE;
     l_end_hist       DATE;

   
   BEGIN
 
     l_error_stage := 'POOL_COMMENTS';

     l_start_comments := SYSDATE;

     SELECT COUNT(*) INTO l_pool_comments('PRE') FROM pool_comments;
  
     DELETE pool_comments  pc
     WHERE  EXISTS (SELECT null
                    FROM    unique_pool up
                    WHERE   pc.owner = up.owner
                    AND     pc.pool_no = up.pool_no
                    AND     return_date + DECODE(owner,400,l_param_bureau_threshold,l_param_court_threshold) < sysdate
                    AND NOT EXISTS (SELECT null
                                    FROM   pool p
                                    WHERE  p.pool_no = up.pool_no
                                    AND    p.owner = up.owner
                                    )
                    );        
     l_deleted_comments := SQL%ROWCOUNT;                   
     l_end_comments := SYSDATE;
 
 
     l_error_stage := 'POOL_STATS';
     l_start_stats := SYSDATE;

     SELECT COUNT(*) INTO l_pool_stats('PRE') FROM pool_stats;
 
     DELETE pool_stats  pc
     WHERE  EXISTS (SELECT null
                    FROM    unique_pool up
                    WHERE   pc.owner = up.owner
                    AND     pc.pool_no = up.pool_no
                    AND     return_date +  DECODE(owner,400,l_param_bureau_threshold,l_param_court_threshold) < sysdate
                    AND NOT EXISTS (SELECT null
                                    FROM   pool p
                                    WHERE  p.pool_no = up.pool_no
                                    AND    p.owner = up.owner
                                    )
                    );
     l_deleted_stats := SQL%ROWCOUNT;                   
     l_end_stats := SYSDATE;
                     
 
     l_error_stage := 'POOL_HIST';
     l_start_hist := SYSDATE;

     SELECT COUNT(*) INTO l_pool_hist('PRE') FROM pool_hist;
 
     DELETE pool_hist  pc
     WHERE  EXISTS (SELECT null
                    FROM    unique_pool up
                    WHERE   pc.owner = up.owner
                    AND     pc.pool_no = up.pool_no
                    AND     return_date + DECODE(owner,400,l_param_bureau_threshold,l_param_court_threshold) < sysdate
                    AND NOT EXISTS (SELECT null
                                    FROM   pool p
                                    WHERE  p.pool_no = up.pool_no
                                    AND    p.owner = up.owner
                                    )
                    );

     l_deleted_hist := SQL%ROWCOUNT;   
     l_end_hist   := SYSDATE;                
                   
      l_error_stage := 'UNIQUE_POOL';
     l_start := SYSDATE;
   
     SELECT COUNT(*) INTO l_unique_pool('PRE')   FROM unique_pool;

     DELETE unique_pool up
     WHERE  return_date + DECODE(owner,400,l_param_bureau_threshold,l_param_court_threshold) < sysdate
     AND    NOT EXISTS (SELECT null
                        FROM   pool p
                        WHERE  p.pool_no = up.pool_no
                        AND    p.owner = up.owner
                         );
     l_deleted := SQL%ROWCOUNT;                   
 
      IF p_read_only_mode THEN
        ROLLBACK;
      ELSE
        COMMIT;  
      END IF;
 
     SELECT COUNT(*) INTO l_unique_pool('POST')   FROM unique_pool;
     SELECT COUNT(*) INTO l_pool_comments('POST') FROM pool_comments;
     SELECT COUNT(*) INTO l_pool_stats('POST')    FROM pool_stats;
     SELECT COUNT(*) INTO l_pool_hist('POST')     FROM pool_hist;
 
     utl_file.put_line(l_file,'POOL_COMMENTS,'||l_deleted_comments||','||TO_CHAR(l_start_comments,'DD-MM-YYYY hh24:MI:SS')||','||TO_CHAR(l_end_comments,'DD-MM-YYYY hh24:MI:SS')||','||l_pool_comments('PRE')||','||l_pool_comments('POST')||','||TO_CHAR(l_pool_comments('PRE')-l_pool_comments('POST')) ,TRUE);
     utl_file.put_line(l_file,'POOL_STATS,'||l_deleted_stats||','||TO_CHAR(l_start_stats,'DD-MM-YYYY hh24:MI:SS')||','||TO_CHAR(l_end_stats,'DD-MM-YYYY hh24:MI:SS')||','||l_pool_stats('PRE')||','||l_pool_stats('POST')||','||TO_CHAR(l_pool_stats('PRE')-l_pool_stats('POST')) ,TRUE);
     utl_file.put_line(l_file,'POOL_HIST,'||l_deleted_hist||','||TO_CHAR(l_start_hist,'DD-MM-YYYY hh24:MI:SS')||','||TO_CHAR(l_end_hist,'DD-MM-YYYY hh24:MI:SS')||','||l_pool_hist('PRE')||','||l_pool_hist('POST')||','||TO_CHAR(l_pool_hist('PRE')-l_pool_hist('POST')),TRUE);
     utl_file.put_line(l_file,'UNIQUE_POOL,'||l_deleted||','||TO_CHAR(l_start,'DD-MM-YYYY hh24:MI:SS')||','||TO_CHAR(sysdate,'DD-MM-YYYY hh24:MI:SS')||','||l_unique_pool('PRE')||','||l_unique_pool('POST')||','||TO_CHAR(l_unique_pool('PRE')-l_unique_pool('POST')),TRUE);
  
   
    EXCEPTION 

     WHEN others THEN
     
       ROLLBACK;
     
       l_err_msg  := SUBSTR(sqlerrm,1,200);
       RAISE e_delete_error; 
 
   END parent_delete_unique_pool;   
   
   -----------
   --
   -----------
  
   
   PROCEDURE report_error(p_part_no VARCHAR, p_owner VARCHAR) IS
  
   BEGIN
    
     utl_file.put_line(l_file,'ERROR. owner:'||p_owner||' part_no:'||p_part_no,TRUE);
     utl_file.put_line(l_file,l_err_msg,TRUE);
     utl_file.put_line(l_file,'Stage : '||l_error_stage);
        
 
   END report_error;

   -----------
   --
   -----------
    
   -- Main body
   BEGIN
  
    record_internal_log_start;
  
    -- open log file   
    initate_log;
  
    -- fetch parameters from HK_PARAMS table
    fetch_parameters;
   
    -- count number of parent records
    OPEN c_part_hist_count(l_param_court_threshold,l_param_bureau_threshold);
    FETCH c_part_hist_count INTO l_part_count;
    CLOSE c_part_hist_count;
   
    IF l_part_count > l_param_max_deletes THEN
       utl_file.put_line(l_file,'Maximum Deletes Parameter exceed. Expected Deletes : '||l_part_count,TRUE);
      RAISE e_max_deletions;
    END IF;   

    -- gather pre-hk row counts
    row_counts_juror('PRE');
 
       utl_file.put_line(l_file,'Time of Deletion,PART_NO,OWNER,Max_DATE_PART,AUDIT_REPORT,AUDIT_F_REPORT,PART_EXPENSES,APPEARANCES,CERT_LETT,CONFIRM_LETT,DEFER_DBF,DEF_LETT,DEF_DENIED,DISQ_LETT,EXC_DENIED_LETT,EXC_LETT,FTA_LETT,MANUALS,PANEL,PART_HIST,PART_AMENDMENTS,POSTPONE_LETT,PHONE_LOG,REQUEST_LETT,UNDELIVR,POOL',TRUE);
   
    FOR l_part_hist IN c_part_hist(l_param_court_threshold,l_param_bureau_threshold) LOOP

      --  dbms_output.put_line('5');
      BEGIN
  
        --write parent record identifier to log
        utl_file.put(l_file,TO_CHAR(sysdate,'dd/mm/yyyy hh24:mi:ss')||','||l_part_hist.part_no||','||l_part_hist.owner||','||TO_CHAR(l_part_hist.maxdate,'dd/mm/yyyy'||','));

        
          -- Delete child tables level 3
          delete_audit_report(l_part_hist.part_no,l_part_hist.owner);
          delete_part_expenses(l_part_hist.part_no,l_part_hist.owner);

          -- Delete child tables level 2
          delete_cert_lett(l_part_hist.part_no,l_part_hist.owner);
          delete_confirm_lett(l_part_hist.part_no,l_part_hist.owner);
          delete_defer_dbf(l_part_hist.part_no,l_part_hist.owner);
          delete_def_lett(l_part_hist.part_no,l_part_hist.owner);
          delete_def_denied(                                     l_part_hist.part_no,l_part_hist.owner);
          delete_disq_lett(l_part_hist.part_no,l_part_hist.owner);
          delete_exc_denied_lett(l_part_hist.part_no,l_part_hist.owner);
          delete_exc_lett(l_part_hist.part_no,l_part_hist.owner);
          delete_fta_lett(l_part_hist.part_no,l_part_hist.owner);
          delete_manuals(l_part_hist.part_no,l_part_hist.owner);
          delete_panel(l_part_hist.part_no,l_part_hist.owner);
          delete_part_hist(l_part_hist.part_no,l_part_hist.owner);
          delete_part_amendments(l_part_hist.part_no,l_part_hist.owner);
          delete_postpone_lett(l_part_hist.part_no,l_part_hist.owner);
          delete_phone_log(l_part_hist.part_no,l_part_hist.owner);
          delete_request_lett(l_part_hist.part_no,l_part_hist.owner);
          delete_undeliver(l_part_hist.part_no,l_part_hist.owner);

          -- delete parent pool record
          delete_pool(l_part_hist.part_no,l_part_hist.owner);
 
          
        IF p_read_only_mode THEN
          ROLLBACK;  
        ELSE
          COMMIT;
        END IF;

        IF NOT p_read_only_mode THEN
          l_cursor_loops := l_cursor_loops + 1;
        END IF;
        
        -- check if time has expired
        check_time_expired;
  
  
      EXCEPTION 
        WHEN e_delete_error THEN
        
          l_pool_errors := l_pool_errors + 1;
  
          report_error(l_part_hist.part_no,l_part_hist.owner);
          ROLLBACK;
        WHEN e_timeout THEN  
          EXIT;
       
      END;
    
    END LOOP;
 
    -- gather post-hk row counts
    row_counts_juror('POST');
    
    -- write table row counts
    write_child_rowcounts;
      
    IF NOT l_time_expired THEN
   
      -- pool parent deletions
      BEGIN
        parent_delete_trial;
      EXCEPTION 
        WHEN e_delete_error THEN
          report_error(null,null);
      END;     
 
      BEGIN
        parent_delete_unique_pool;
      EXCEPTION 
        WHEN e_delete_error THEN
          report_error(null,null);
      END;     
   
    END IF;
    
    -- delete from stand alone tables
    
    -- each one will independantly commit or rollback and report to log file/error log
    -- timeout is checked in each procedure and propegates exception back out 

    BEGIN
      IF NOT l_time_expired THEN

        utl_file.put_line(l_file,' ',TRUE); 
        utl_file.put_line(l_file,'Row Counts for STAND ALONE tables',TRUE); 
        utl_file.put_line(l_file,'Table,Selected,Start Time,End Time,Before,After,Deleted',TRUE); 
      
        delete_sa_abaccus;
        delete_sa_aramis_payments;
        delete_sa_attendance;
        delete_sa_content_store;
        delete_sa_error_log;
        delete_sa_holidays;
        delete_sa_module_machine_xref;
        delete_sa_pl_xml_status;
        delete_sa_print_files;
        delete_sa_peak_usage;
        delete_sa_coroner;
    
      END IF;
    EXCEPTION 
      WHEN e_timeout THEN
        null;
    END;
 
    IF l_time_expired THEN
      write_footer(6);
    ELSE  
      write_footer(0);
    END IF;
      
    close_log;
   
    

    -- success
    RETURN 0;
 
  EXCEPTION 

         
    WHEN e_log_error THEN
 
      -- problem with log file
      RETURN 3;
 
    WHEN e_param_error THEN
 
      -- problem with parameter table

      utl_file.put_line(l_file,'RETURN CODE 4 : Missing Parameters' ,TRUE);
    
      utl_file.fclose(l_file);
      RETURN 4;
      
    WHEN e_max_deletions THEN

      utl_file.put_line(l_file,'RETURN CODE 5 : Maximum Deletions' ,TRUE);
    
      utl_file.fclose(l_file);
      RETURN 5;
      
     WHEN others THEN  

      -- unspecified fatal error
      RETURN 2;
      
  END initiate_run;    
    
     
END Housekeeping;
