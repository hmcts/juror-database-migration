-- Generated by Ora2Pg, the Oracle database Schema converter, version 24.0
-- Copyright 2000-2023 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=172.17.0.5;sid=xe;port=1521

SET client_encoding TO 'UTF8';

SET search_path = "JUROR",public;
\set ON_ERROR_STOP ON

function get_voters       ( p_required in number, -- Required number of jurors
                           	p_minDate  in date,   -- Not less than 18yrs old
  				p_maxDate	in date ,  -- Not over 70 yrs old
				p_LocCode  in varchar2,
        p_areacode_list in varchar2,   -- comma separated list used with SQL IN clause below
        p_areacode_all_yn in varchar2, -- 'Y' for all area codes
        p_pool_type in varchar2 )      -- 'C'ORONER OR 'N'ON CORONER POOLS (REGULAR POOL)
    return VotersRowidTable
-----------------------------------------------------------------------------------
--  Function: get_voters()
--
--  Parms in: p_required in number, -- Required number of jurors
--            p_minDate  in date,   -- Not less than 18yrs old
--  				  p_maxDate	in date ,  -- Not over 70 yrs old
--				    p_LocCode  in varchar2, -- post code area
--            p_areacode_list in varchar2,   -- comma separated list used with SQL IN clause below
--            p_areacode_all_yn in varchar2, -- 'Y' for all area codes
--            p_pool_type in varchar2 -- -- 'C'ORONER OR 'N'ON CORONER POOLS (REGULAR POOL)
--
--  Returns:  VotersRowidTable - Selected voters rowids
--
--  Description
--  ===========
--  Returns random selection of voters(ROWIDS) from the postcode area specified and other parms.
--
--  History
--
--	Version Name		  Date		 Desc
--	======= ========= ======== ====
--  V1.0    ???       ???      Initial version
--	V1.1    Kal Sohal 01/08/07 RFC 1731 Juror source list and pool selection.
--                             Added code to permit selection from specified postcode areas and for pool type (Coroner or Regular Pool)
--  V1.2    kal Sohal 29/11/07 UAT bug fix for NULLpostcode areas. Added decode to handle potential NULLS and convert to 1 char space string.
-----------------------------------------------------------------------------------
    as
      l_data             VotersRowidTable := VotersRowidTable();
      l_cnt              number default 0;
	  e_less_voters		 exception;
	  e_empty_list		 exception;
	  l_cursor 			 sys_refcursor;

	  type t_flags is table of varchar2(2) index by binary_integer;
	  tab_flags t_flags;

	  type t_rowid is table of varchar2(30) index by binary_integer;
	  tab_rowid t_rowid;

	  l_julian_min_dt number := to_number(to_char(p_minDate,'J')); -- Since the input date format cannot be guaranteed  across varios systems,
  	  l_julian_max_dt number := to_number(to_char(p_maxDate,'J')); -- I am changing it to Julian Format.
	  l_found boolean;

  begin

	-- Open dynamic cursor against the required table
  -- RFC1731 non coroner pool rules...other rules apply for coroner pools....
	   open l_cursor for ' select rowidtochar(rowid) row_id, flags '||
	   				 ' from voters'||p_LocCode||
						 ' where date_selected1 is null '||
						 ' and ((DOB is null) OR '||
						 ' (( to_number(to_char(DOB,''J'')) > '||l_julian_min_dt||' ) AND '||
						 '  ( to_number(to_char(DOB,''J'')) < '||l_julian_max_dt||' )))'||
						 ' and PERM_DISQUAL is null '||
             ' and ( Decode(substr(zip,1, instr(zip, '' '') -1 ), NULL, '' '', Trim(substr(zip,1, instr(zip, '' '') -1 ))) IN ('||p_areacode_list||')' || -- v1.1 >> RFC 1731 specified postcode areas V1.2 <<
             ' or '''||p_areacode_all_yn||'''  = ''Y'' )' ||                             -- or if ALL areas specified
             ' and ( FLAGS is null OR '''||p_pool_type||'''  = ''N'' )' ||               -- only coronor pools check flag v1.1 <<
						 ' order by dbms_random.value';

	   loop
	    fetch l_cursor BULK COLLECT into tab_rowid,tab_flags  limit p_required*1.2;

		-- I am using BULK COLLECT  and  LIMIT clauses, so that if the required participants fall short due to
		-- disqualified on selection categories, then there is no need to revisit the table once again
		l_found := false;
		  for i in 1..tab_rowid.count
		  loop
              l_data.extend;
	    					IF  tab_flags(i) IS NULL THEN

            					l_cnt := l_cnt + 1; -- Count only people with null values in Flagscolumn
								l_found := l_cnt > to_number(p_required) ;
							END IF;

		  exit when l_found; -- exit the inner loop when required number is found
              l_data(l_data.count) := VotersRowidType(tab_rowid(i) );

          end loop;
	   exit when l_found or l_cursor%notfound ;
       end loop;
       close l_cursor;


	  IF l_cnt = 0 THEN
	     raise e_empty_list; -- Raise this exception if the voters table is empty
	  END IF;

      IF l_cnt < p_required THEN
	     raise e_less_voters; -- Raise this exception when number of participants found is less than required
	  END IF;

      return l_data; -- return rowid list
  exception
  	  when e_less_voters then
	     raise_application_error(-20001, 'Voters list is low');
	  when e_empty_list then
	     raise_application_error(-20002, 'Voters list is empty');
  end;

